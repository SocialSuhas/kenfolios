//// =========================================================
//// WORKER PART 1 / 5
//// From file start → helpers + constants
//// =========================================================

/**
 * kf-members-submit-z9p4x-worker — complete
 * - Generates & persists order_url/ref_id on create-order and on initial join
 * - Generates & persists unique_token/activation_url on payment confirm
 * - BASE_PRODUCT is GST-inclusive (1999 INR)
 * - Optional MAILER_WEBHOOK env: receives JSON payloads for order_created and activation events
 *
 * Bindings required:
 * env.D1_WRITE_BINDING (Cloudflare D1)
 *
 * Optional env vars:
 * env.RAZORPAY_KEY_ID
 * env.RAZORPAY_KEY_SECRET
 * env.ALLOWED_ORIGINS
 * env.MAILER_WEBHOOK
 *
 * Telegram-related env vars:
 * env.TELEGRAM_BOT_TOKEN
 * env.TELEGRAM_WEBHOOK_SECRET
 * env.TELEGRAM_GROUP_ID
 * env.TELEGRAM_GROUP_INVITE_LINK
 *
 * Brevo-related env vars:
 * env.BREVO_API_KEY
 * env.BREVO_SENDER_EMAIL
 * env.BREVO_SENDER_NAME
 * env.BREVO_TEMPLATE_ID
 *
 * AWS SES (order email only):
 * env.SES_ENABLED
 * env.SES_ACCESS_KEY_ID
 * env.SES_SECRET_ACCESS_KEY
 * env.SES_REGION
 * env.SES_FROM_EMAIL
 * env.AWS_SES_FROM_NAME
 */

const JSON_HEADERS = { "Content-Type": "application/json; charset=utf-8" };

function corsHeaders(origin) {
  return {
    "Access-Control-Allow-Origin": origin || "*",
    "Access-Control-Allow-Methods": "GET,POST,PATCH,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type,Accept"
  };
}

function json(body, status = 200, origin = "*") {
  return new Response(JSON.stringify(body), {
    status,
    headers: { ...JSON_HEADERS, ...corsHeaders(origin) }
  });
}

// --- Product / tax config (server authoritative) ---
const BASE_PRODUCT = {
  name: "Activation fee",
  base_price: 1999,
  currency: "INR",
  inclusive_gst: true
};
const GST_RATE = 0.18;

// --- Coupon definitions (server authoritative) ---
const COUPONS = {
  "KEN100": { code: "KEN100", type: "flat", amount: 100, min: 0, stackable: false },
  "VSTREET20": { code: "VSTREET20", type: "percent", pct: 20, cap: 400, min: 0, stackable: false },
  "LAUNCH500": { code: "LAUNCH500", type: "flat", amount: 500, min: 1499, stackable: false },
  "FOUNDER100": {
    code: "FOUNDER100",
    type: "percent",
    pct: 100,
    cap: BASE_PRODUCT.base_price,
    min: 0,
    stackable: false
  }
};

// --- Optional per-coupon limits (usage + expiry) ---
const COUPON_LIMITS = {
  FOUNDER100: {
    maxUses: 99,
    expiresAt: "2025-12-31T23:59:59Z"
  }
};

function moneyRound(n) { return Math.round(n); }

/**
 * applyCouponAndTotals
 * - Accepts basePrice (INCLUSIVE of GST) and couponCode
 * - Returns subtotal (base/inclusive), discount, taxable, gst, total
 */
function applyCouponAndTotals(basePrice, couponCode) {
  const inclusive = Number(basePrice);
  let discount = 0;
  let appliedCoupon = null;

  if (couponCode) {
    const c = COUPONS[couponCode];
    if (c) {
      if (c.type === "flat") {
        if (inclusive < (c.min || 0)) {
          return { error: `Coupon ${couponCode} requires minimum order ₹${c.min}.` };
        }
        discount = Number(c.amount || 0);
        appliedCoupon = c;
      } else if (c.type === "percent") {
        const raw = (inclusive * (Number(c.pct || 0) / 100));
        const capped = c.cap ? Math.min(raw, Number(c.cap)) : raw;
        discount = moneyRound(capped);
        appliedCoupon = c;
      } else {
        return { error: `Invalid coupon type for ${couponCode}.` };
      }
    } else {
      return { error: `Invalid coupon code.` };
    }
  }

  if (discount > inclusive) discount = inclusive;
  const total = moneyRound(inclusive - discount);
  const taxableRaw = total / (1 + GST_RATE);
  const taxable = moneyRound(taxableRaw);
  const gst = moneyRound(total - taxable);

  return {
    subtotal: moneyRound(inclusive),
    discount: moneyRound(discount),
    taxable,
    gst,
    total,
    applied_coupon: appliedCoupon ? appliedCoupon.code : null
  };
}

// --- Helpers ---
function pathParts(url) {
  const u = new URL(url);
  return u.pathname.replace(/\/+$/, "").split("/").filter(Boolean);
}

function generateRefFromMember(memberId) {
  const alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const a = alpha.charCodeAt(memberId % alpha.length) || 65;
  const b = alpha.charCodeAt((memberId + 3) % alpha.length) || 65;
  const c = alpha.charCodeAt((memberId + 7) % alpha.length) || 65;
  const letters = String.fromCharCode(a, b, c);
  const numpart = String((memberId * 37 + 1234) % 10000).padStart(4, '0');
  const idpart = String(memberId).padStart(6, '0');
  return `${letters}${numpart}-${idpart}`;
}

function generateUniqueToken(len = 28) {
  const bytes = new Uint8Array(Math.ceil(len * 0.75));
  crypto.getRandomValues(bytes);
  let s = '';
  for (let i = 0; i < bytes.length; i++) {
    s += bytes[i].toString(36);
  }
  return s.replace(/[^a-z0-9]/gi, '').slice(0, len);
}

// -------------------------------------------------
// NEW ADDITION (NO SIDE EFFECT): ORDER EMAIL HTML
// -------------------------------------------------

const ORDER_EMAIL_HTML = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Welcome to KenFolios Business Community</title>
</head>
<body style="margin:0;padding:0;background:#f6f6f6;font-family:Arial,Helvetica,sans-serif;color:#333;">
  <table width="100%" cellpadding="0" cellspacing="0" style="padding:20px 0;">
    <tr>
      <td align="left">
        <table width="600" cellpadding="0" cellspacing="0"
          style="background:#ffffff;border-radius:6px;padding:30px;margin:0;">

          <h1 style="margin:0 0 20px 0;font-size:22px;color:#111;font-weight:700;">
            Welcome to KenFolios Business Community
          </h1>

          <p>Dear <strong>{{FULL_NAME}}</strong>,</p>

          <p>
            You are registered for the <strong>KenFolios Business Community</strong>.
          </p>

          <p>
            Below is your order for the one-time membership activation fee.
            You can use the button below to view and pay your order.
          </p>

          <p>
            You may also apply any available <strong>discount coupon code</strong>
            on the payment page before completing your payment.
          </p>

          <p>
            <a href="{{ORDER_URL}}"
               style="display:inline-block;background:#E11D2E;color:#ffffff;
                      text-decoration:none;padding:12px 22px;border-radius:6px;
                      font-size:15px;font-weight:600;">
              View &amp; Pay Order
            </a>
          </p>

          <p style="font-size:13px;color:#555;">
            If the button does not work, copy this link:<br/>
            <span style="word-break:break-all;">{{ORDER_URL}}</span>
          </p>

          <table width="100%" cellpadding="0" cellspacing="0"
            style="background:#F9FAFB;border:1px solid #E5E7EB;margin-bottom:22px;">
            <tr>
              <td colspan="2" style="padding:10px;font-weight:600;">Order Details</td>
            </tr>
            <tr>
              <td style="padding:8px;">Order Number</td>
              <td style="padding:8px;">{{ORDER_REF}}</td>
            </tr>
            <tr>
              <td style="padding:8px;">Order Created On</td>
              <td style="padding:8px;">{{ORDER_CREATED_AT}}</td>
            </tr>
            <tr>
              <td style="padding:8px;">Amount Payable</td>
              <td style="padding:8px;">₹{{ORDER_TOTAL}}</td>
            </tr>
            <tr>
              <td style="padding:8px;">Payment Status</td>
              <td style="padding:8px;">Pending payment</td>
            </tr>
          </table>

          <p style="font-size:12px;color:#6B7280;">
            <strong>KenFolios Media Private Limited</strong><br/>
            Second Floor, F-328, Lado Sarai,<br/>
            New Delhi – 110030, India
          </p>

          <p style="font-size:11px;color:#9CA3AF;">
            © {{YEAR}} KenFolios Media Private Limited. All rights reserved.
          </p>

        </table>
      </td>
    </tr>
  </table>
</body>
</html>`;
//// =========================================================
//// WORKER PART 2 / 5
//// Coupon helpers, Razorpay helpers, mail helpers
//// (UNCHANGED) + SES send helper (NEW)
//// =========================================================

// --- Razorpay signature helper (HMAC SHA256) ---
async function hmacSHA256Hex(secret, message) {
  const enc = new TextEncoder();
  const keyData = enc.encode(secret);
  const msgData = enc.encode(message);

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );

  const sigBuf = await crypto.subtle.sign("HMAC", cryptoKey, msgData);
  const bytes = new Uint8Array(sigBuf);
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += bytes[i].toString(16).padStart(2, "0");
  }
  return hex;
}

async function verifyRazorpaySignature(secret, orderId, paymentId, signature) {
  if (!secret) return false;
  if (!orderId || !paymentId || !signature) return false;
  const payload = `${orderId}|${paymentId}`;
  const computed = await hmacSHA256Hex(secret, payload);
  return computed === signature;
}

function buildCompanyBlock() {
  return {
    name: "KenFolios Media Private Limited",
    address: "Second floor, F-328, Lado Sarai, New Delhi, Delhi, 110030",
    gstin: "07AAGCK7129K1Z7",
    cin: "U72900DL2017PTC321788"
  };
}

// --- Optional mailer webhook (fire-and-forget) ---
async function fireMailerWebhook(env, payload) {
  try {
    if (!env.MAILER_WEBHOOK) return;
    fetch(env.MAILER_WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).catch(e => {
      console.error('Mailer webhook failed (fire-and-forget):', String(e));
    });
  } catch (e) {
    console.error('Mailer webhook error:', String(e));
  }
}

// --- Brevo helper: send activation email via template or fallback HTML ---
async function sendActivationEmail(env, toEmail, fullName, activationUrl) {
  try {
    if (!env.BREVO_API_KEY) {
      console.error("Brevo: BREVO_API_KEY missing, skip email.");
      return null;
    }
    if (!toEmail || !activationUrl) {
      console.error("Brevo: missing toEmail or activationUrl, skip email.");
      return null;
    }

    const name = fullName && fullName.trim() ? fullName.trim() : "Member";
    const senderEmail = env.BREVO_SENDER_EMAIL || "no-reply@kenfolios.com";
    const senderName = env.BREVO_SENDER_NAME || "KenFolios Business Community";

    let payload;
    const templateIdNum = env.BREVO_TEMPLATE_ID ? Number(env.BREVO_TEMPLATE_ID) : NaN;

    if (!isNaN(templateIdNum) && templateIdNum > 0) {
      payload = {
        to: [{ email: toEmail, name }],
        templateId: templateIdNum,
        params: {
          name,
          activation_link: activationUrl
        }
      };
    } else {
      payload = {
        sender: { email: senderEmail, name: senderName },
        to: [{ email: toEmail, name }],
        subject: "Activate Your KenFolios Business Community Account",
        htmlContent: `<!DOCTYPE html><html><body>
          <p>Hi ${name},</p>
          <p>Please activate your account:</p>
          <p><a href="${activationUrl}">Activate</a></p>
        </body></html>`
      };
    }

    const res = await fetch("https://api.brevo.com/v3/smtp/email", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "api-key": env.BREVO_API_KEY
      },
      body: JSON.stringify(payload)
    });

    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      console.error("Brevo send email failed:", res.status, JSON.stringify(data));
    }
    return data;
  } catch (e) {
    console.error("Brevo sendActivationEmail error:", String(e));
    return null;
  }
}

// -------------------------------------------------
// NEW ADDITION: AWS SES send helper (SEND ONLY)
// -------------------------------------------------
async function sendOrderEmailViaSES(env, params) {
  try {
    if (env.SES_ENABLED !== "true") return;

    const {
      to,
      fullName,
      order_ref,
      order_url,
      totals,
      order_created_at
    } = params || {};

    if (!to || !order_url || !order_ref) return;

    const region = env.SES_REGION;
    const accessKeyId = env.SES_ACCESS_KEY_ID;
    const secretAccessKey = env.SES_SECRET_ACCESS_KEY;
    const fromEmail = env.SES_FROM_EMAIL;
    const fromName = env.AWS_SES_FROM_NAME || "KenFolios Business Community";

    if (!region || !accessKeyId || !secretAccessKey || !fromEmail) {
      console.error("SES config missing, skip order email.");
      return;
    }

    const html = ORDER_EMAIL_HTML
      .replace(/{{FULL_NAME}}/g, fullName || "Member")
      .replace(/{{ORDER_URL}}/g, order_url)
      .replace(/{{ORDER_REF}}/g, order_ref)
      .replace(/{{ORDER_CREATED_AT}}/g, order_created_at || new Date().toISOString())
      .replace(/{{ORDER_TOTAL}}/g, totals && totals.total != null ? totals.total : "")
      .replace(/{{YEAR}}/g, new Date().getFullYear());

    const rawEmail =
`From: "${fromName}" <${fromEmail}>
To: ${to}
Subject: Welcome to KenFolios Business Community
MIME-Version: 1.0
Content-Type: text/html; charset=UTF-8

${html}`;

    const encoder = new TextEncoder();
    const rawBytes = encoder.encode(rawEmail);
    const rawBase64 = btoa(String.fromCharCode(...rawBytes));

    const payload = `Action=SendRawEmail&RawMessage.Data=${encodeURIComponent(rawBase64)}`;
    const host = `email.${region}.amazonaws.com`;
    const amzDate = new Date().toISOString().replace(/[:-]|\.\d{3}/g, "");
    const dateStamp = amzDate.slice(0, 8);

    async function hmac(key, data) {
      const k = await crypto.subtle.importKey("raw", key, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
      return crypto.subtle.sign("HMAC", k, data);
    }

    const enc = new TextEncoder();
    const kDate = await hmac(enc.encode("AWS4" + secretAccessKey), enc.encode(dateStamp));
    const kRegion = await hmac(kDate, enc.encode(region));
    const kService = await hmac(kRegion, enc.encode("ses"));
    const kSigning = await hmac(kService, enc.encode("aws4_request"));

    const signatureBytes = await hmac(
      kSigning,
      enc.encode("AWS4-HMAC-SHA256\n" + amzDate)
    );

    const signature = Array.from(new Uint8Array(signatureBytes))
      .map(b => b.toString(16).padStart(2, "0"))
      .join("");

    const authHeader =
      `AWS4-HMAC-SHA256 Credential=${accessKeyId}/${dateStamp}/${region}/ses/aws4_request, SignedHeaders=host;x-amz-date, Signature=${signature}`;

    await fetch(`https://${host}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded",
        "X-Amz-Date": amzDate,
        "Authorization": authHeader
      },
      body: payload
    });

  } catch (e) {
    console.error("SES order email error:", String(e));
  }
}
//// =========================================================
//// WORKER PART 3 / 5
//// Worker entrypoint + routing (UNCHANGED)
//// =========================================================

// --- Worker entrypoint ---
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const origin = request.headers.get("Origin") || "*";
    const rawPath = url.pathname.replace(/\/+$/, "") || "/";
    const isTelegramWebhookPath =
      rawPath === "/api/telegram/webhook" || rawPath.endsWith("/api/telegram/webhook");

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders(origin) });
    }

    if (!env.D1_WRITE_BINDING) {
      return json({ ok: false, message: "D1 binding not found (env.D1_WRITE_BINDING)" }, 500, origin);
    }

    // Apply ALLOWED_ORIGINS check for browser/API calls, but NOT for Telegram webhook
    if (!isTelegramWebhookPath && env.ALLOWED_ORIGINS && env.ALLOWED_ORIGINS.trim()) {
      const allowed = env.ALLOWED_ORIGINS.split(',').map(s => s.trim()).filter(Boolean);
      if (allowed.length && origin !== "*" && !allowed.includes(origin)) {
        return json({ ok: false, message: "Origin not allowed" }, 403, origin);
      }
    }

    try {
      if ((rawPath === "/api/join" || rawPath.endsWith("/api/join")) && request.method === "POST") {
        return await handleJoin(request, env, origin);
      }
      if (rawPath.startsWith("/api/member/") && request.method === "PATCH") {
        return await handlePatchMember(request, env, origin);
      }
      if ((rawPath === "/api/payment/create-order" || rawPath.endsWith("/api/payment/create-order")) && request.method === "POST") {
        return await handleCreateOrder(request, env, origin);
      }
      if ((rawPath === "/api/payment/confirm" || rawPath.endsWith("/api/payment/confirm")) && request.method === "POST") {
        return await handlePaymentConfirm(request, env, origin);
      }
      if ((rawPath === "/api/payment/confirm-v2" || rawPath.endsWith("/api/payment/confirm-v2")) && request.method === "POST") {
        return await handlePaymentConfirmV2(request, env, origin);
      }
      if ((rawPath === "/api/order/by-ref" || rawPath.endsWith("/api/order/by-ref")) && request.method === "POST") {
        return await handleFetchOrderByRef(request, env, origin);
      }

      // -----------------------------------------------
      // Telegram Webhook Endpoint — Activation & Auto-Approval
      // -----------------------------------------------
      if (
        (rawPath === "/api/telegram/webhook" || rawPath.endsWith("/api/telegram/webhook")) &&
        request.method === "POST"
      ) {
        // Verify webhook secret (set via setWebhook & TELEGRAM_WEBHOOK_SECRET)
        const tgSecret = request.headers.get("X-Telegram-Bot-Api-Secret-Token") || "";
        if (env.TELEGRAM_WEBHOOK_SECRET && tgSecret !== env.TELEGRAM_WEBHOOK_SECRET) {
          return new Response("Unauthorized", { status: 401 });
        }

        let update = {};
        try {
          update = await request.json();
        } catch (e) {
          console.error("Telegram webhook JSON parse error:", e);
          return new Response("Bad request", { status: 400 });
        }

        console.log("Telegram update received:", JSON.stringify(update));

        const db = env.D1_WRITE_BINDING;
        const BOT_TOKEN = env.TELEGRAM_BOT_TOKEN;
        const GROUP_ID = env.TELEGRAM_GROUP_ID;
        const INVITE_LINK = env.TELEGRAM_GROUP_INVITE_LINK || null;

        async function callTelegram(method, payload) {
          if (!BOT_TOKEN) {
            console.error("TELEGRAM_BOT_TOKEN missing");
            return null;
          }
          try {
            const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/${method}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            const j = await res.json().catch(() => ({}));
            if (!res.ok || !j.ok) {
              console.error("Telegram API error", method, res.status, JSON.stringify(j));
            }
            return j;
          } catch (e) {
            console.error("Telegram API fetch error", method, String(e));
            return null;
          }
        }

        async function sendDM(chatId, text) {
          if (!BOT_TOKEN || !chatId) return;
          return await callTelegram("sendMessage", {
            chat_id: chatId,
            text: text,
            parse_mode: "HTML",
            disable_web_page_preview: true
          });
        }

        async function approveJoinRequest(chatId, userId) {
          return await callTelegram("approveChatJoinRequest", {
            chat_id: chatId,
            user_id: userId
          });
        }

        async function declineJoinRequest(chatId, userId) {
          return await callTelegram("declineChatJoinRequest", {
            chat_id: chatId,
            user_id: userId
          });
        }

        // (Telegram logic continues in PART 4)
//// =========================================================
//// WORKER PART 4 / 5
//// Handlers: join, patch, create-order (SES added)
//// =========================================================

// ---------------- Handlers ----------------
async function parseJsonSafe(request) {
  const ct = (request.headers.get("content-type") || "").toLowerCase();
  if (ct.includes("application/json")) return await request.json();
  const txt = await request.text();
  try { return txt ? JSON.parse(txt) : {}; } catch { return {}; }
}

async function handleJoin(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const full_name = (body.name || body.fullName || body.full_name || "").toString().trim();
  const dob = (body.dob || "").toString().trim();
  const gender = (body.gender || "").toString().trim();
  const city = (body.city || "").toString().trim();
  const email = (body.email || "").toString().trim().toLowerCase();
  const phone = (body.phone || "").toString().trim();
  const expectations = Array.isArray(body.expectations)
    ? body.expectations.join(',')
    : (body.expectations || body.expect || "").toString();
  const accept = (body.accept || body.accepted || body.fi_accept) ? 1 : 0;
  const created_at = new Date().toISOString();

  if (!full_name || !dob || !gender || !city || !email || !phone) {
    return json({ ok: false, message: "Missing required fields (name,dob,gender,city,email,phone required)" }, 400, origin);
  }
  if (!/@/.test(email) || phone.length < 6) {
    return json({ ok: false, message: "Invalid email or phone" }, 400, origin);
  }

  // ---- UNCHANGED JOIN LOGIC ----
  // (exactly same as your current worker; omitted comments for brevity)

  // join logic continues exactly as before…
}

/* ---------------------------------------------------------
 * handlePatchMember — UNCHANGED
 * --------------------------------------------------------- */

async function handlePatchMember(request, env, origin) {
  // unchanged body (same as your existing worker)
  // no SES involvement here
}

/* ---------------------------------------------------------
 * handleCreateOrder — SES EMAIL ADDED (ONLY PLACE)
 * --------------------------------------------------------- */

async function handleCreateOrder(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const member_id = Number(body.member_id || body.memberId);
  const applyCoupon = (body.coupon || body.coupon_code || body.couponCode || null);
  const simulate = body.simulate || false;

  if (!member_id) {
    return json({ ok: false, message: "member_id required" }, 400, origin);
  }

  const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
    .bind(member_id).all();
  if (!lookup || !lookup.results || !lookup.results[0]) {
    return json({ ok: false, message: "Member not found" }, 404, origin);
  }

  const member = lookup.results[0];

  if (member.activation_fee_status === 'paid') {
    return json({
      ok: false,
      message: "Activation fee already paid for this member",
      reason: "already_paid"
    }, 409, origin);
  }

  const totalsRes = applyCouponAndTotals(BASE_PRODUCT.base_price, applyCoupon);
  if (totalsRes.error) {
    return json({ ok: false, message: totalsRes.error }, 400, origin);
  }

  const order_ref = generateRefFromMember(member_id);
  const order_url = `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;

  // persist order refs (UNCHANGED)
  await db.prepare(`
    UPDATE members
    SET
      ref_id = COALESCE(ref_id, ?),
      order_url = COALESCE(order_url, ?),
      activation_order_token = COALESCE(activation_order_token, ?)
    WHERE id = ?;
  `).bind(order_ref, order_url, order_ref, member_id).run();

  const afterSet = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
    .bind(member_id).all();
  const memberAfter = afterSet.results[0];

  if (simulate) {
    return json({
      ok: true,
      message: "Simulated order totals",
      order: buildOrderObject(member_id, memberAfter, totalsRes)
    }, 200, origin);
  }

  // ---------------- NO RAZORPAY PATH ----------------
  if (!env.RAZORPAY_KEY_ID || !env.RAZORPAY_KEY_SECRET) {

    // >>> AWS SES ORDER EMAIL (NEW)
    try {
      if (env.SES_ENABLED === "true" && memberAfter.email) {
        await sendOrderEmailViaSES(env, {
          to: memberAfter.email,
          fullName: memberAfter.full_name || "Member",
          order_ref,
          order_url,
          totals: totalsRes,
          order_created_at: new Date().toISOString()
        });
      }
    } catch (e) {
      console.error("SES order email failed (no-razorpay):", String(e));
    }

    return json({
      ok: true,
      razorpay_configured: false,
      order: buildOrderObject(member_id, memberAfter, totalsRes)
    }, 200, origin);
  }

  // ---------------- RAZORPAY PATH ----------------
  // (Razorpay order creation unchanged)

  // AFTER Razorpay order is created successfully:

  // >>> AWS SES ORDER EMAIL (NEW)
  try {
    if (env.SES_ENABLED === "true" && memberAfter.email) {
      await sendOrderEmailViaSES(env, {
        to: memberAfter.email,
        fullName: memberAfter.full_name || "Member",
        order_ref,
        order_url,
        totals: totalsRes,
        order_created_at: new Date().toISOString()
      });
    }
  } catch (e) {
    console.error("SES order email failed (after-razorpay):", String(e));
  }

  // return response unchanged…
}
//// =========================================================
//// WORKER PART 5 / 5
//// Payment confirm handlers, order builder, helpers
//// (UNCHANGED)
//// =========================================================

// ---------------- Payment confirmation handlers ----------------

async function handlePaymentConfirm(request, env, origin) {
  // UNCHANGED — exactly as in your current worker
}

async function handlePaymentConfirmV2(request, env, origin) {
  // UNCHANGED — exactly as in your current worker
}

// ---------------- Fetch order by ref_id ----------------

async function handleFetchOrderByRef(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const ref_id = (body.ref_id || body.refId || '').toString().trim();

  if (!ref_id) {
    return json({ ok: false, message: "ref_id required" }, 400, origin);
  }

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE ref_id = ? LIMIT 1")
      .bind(ref_id).all();

    if (!lookup || !lookup.results || !lookup.results[0]) {
      return json({ ok: false, message: "Order not found" }, 404, origin);
    }

    const member = lookup.results[0];
    const order = buildOrderObject(member.id, member, null);

    return json({ ok: true, order }, 200, origin);

  } catch (err) {
    console.error("handleFetchOrderByRef error:", String(err));
    return json({ ok: false, message: "Internal error" }, 500, origin);
  }
}

// ---------------- Order builder & helpers ----------------

function buildOrderObject(memberId, memberRow, totalsOverride) {
  const member = memberRow ? {
    id: memberRow.id,
    full_name: memberRow.full_name,
    email: memberRow.email,
    phone: memberRow.phone,
    city: memberRow.city,
    dob: memberRow.dob,
    gender: memberRow.gender,
    expectations: memberRow.expectations
  } : {};

  const order_ref = memberRow && memberRow.ref_id
    ? memberRow.ref_id
    : generateRefFromMember(memberId);

  const totals = totalsOverride
    ? totalsOverride
    : applyCouponAndTotals(
        BASE_PRODUCT.base_price,
        memberRow && memberRow.activation_coupon_code
          ? memberRow.activation_coupon_code
          : null
      );

  const status = (memberRow && memberRow.activation_fee_status === 'paid') ? 'paid' : 'pending';
  const editable = status !== 'paid';

  const available_coupons = Object.values(COUPONS).map(c => ({
    code: c.code,
    type: c.type,
    amount: c.amount || null,
    pct: c.pct || null,
    cap: c.cap || null,
    min: c.min || 0
  }));

  let order_created_at = null;
  if (memberRow && memberRow.activation_created_at) {
    try {
      const sec = Number(memberRow.activation_created_at);
      if (!isNaN(sec)) order_created_at = new Date(sec * 1000).toISOString();
    } catch {}
  }

  if (!order_created_at && memberRow && memberRow.created_at) {
    order_created_at = new Date(memberRow.created_at).toISOString();
  }

  if (!order_created_at) order_created_at = new Date().toISOString();

  const order_url = memberRow && memberRow.order_url
    ? memberRow.order_url
    : `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;

  const activation_url = memberRow && memberRow.activation_url
    ? memberRow.activation_url
    : (memberRow && memberRow.unique_token
        ? `https://kenfolios.com/community?activation=${encodeURIComponent(memberRow.unique_token)}`
        : null);

  return {
    order_ref,
    order_created_at,
    order_url,
    activation_url,
    ref_id: order_ref,
    member,
    product: {
      name: BASE_PRODUCT.name,
      base_price: BASE_PRODUCT.base_price,
      currency: BASE_PRODUCT.currency
    },
    available_coupons,
    applied_coupon: totals.applied_coupon || null,
    totals: {
      subtotal: totals.subtotal,
      discount: totals.discount,
      taxable: totals.taxable,
      gst: totals.gst,
      total: totals.total
    },
    status,
    editable,
    company: buildCompanyBlock()
  };
}

async function readMemberCountOrFallback(db) {
  try {
    const metaRes = await db.prepare("SELECT value FROM meta WHERE key = 'member_count' LIMIT 1").all();
    if (metaRes && metaRes.results && metaRes.results[0] && metaRes.results[0].value != null) {
      return Number(metaRes.results[0].value) || 0;
    } else {
      const cntRes = await db.prepare("SELECT COUNT(*) AS cnt FROM members").all();
      if (cntRes && cntRes.results && cntRes.results[0] && cntRes.results[0].cnt != null) {
        return Number(cntRes.results[0].cnt) || 0;
      }
    }
  } catch (err) {
    console.error("count read failed:", String(err));
  }
  return null;
}
