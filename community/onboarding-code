/**
 * kf-members-submit-z9p4x-worker â€” complete
 * - Generates & persists order_url/ref_id on create-order and on initial join
 * - Generates & persists unique_token/activation_url on payment confirm
 * - BASE_PRODUCT is GST-inclusive (1999 INR)
 * - Optional MAILER_WEBHOOK env: receives JSON payloads for order_created and activation events
 *
 * Bindings required:
 * env.D1_WRITE_BINDING (Cloudflare D1)
 * Optional env vars:
 * env.RAZORPAY_KEY_ID
 * env.RAZORPAY_KEY_SECRET
 * env.ALLOWED_ORIGINS
 * env.MAILER_WEBHOOK
 *
 * Drop-in replacement for your existing worker.
 */

const JSON_HEADERS = { "Content-Type": "application/json; charset=utf-8" };

function corsHeaders(origin) {
  return {
    "Access-Control-Allow-Origin": origin || "*",
    "Access-Control-Allow-Methods": "GET,POST,PATCH,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type,Accept"
  };
}

function json(body, status = 200, origin = "*") {
  return new Response(JSON.stringify(body), { status, headers: { ...JSON_HEADERS, ...corsHeaders(origin) } });
}

// --- Product / tax config (server authoritative) ---
const BASE_PRODUCT = { name: "Activation fee", base_price: 1999, currency: "INR", inclusive_gst: true };
const GST_RATE = 0.18;

// --- Coupon definitions (server authoritative) ---
const COUPONS = {
  "KEN100": { code: "KEN100", type: "flat", amount: 100, min: 0, stackable: false },
  "VSTREET20": { code: "VSTREET20", type: "percent", pct: 20, cap: 400, min: 0, stackable: false },
  "LAUNCH500": { code: "LAUNCH500", type: "flat", amount: 500, min: 1499, stackable: false }
};

function moneyRound(n) { return Math.round(n); }

/**
 * applyCouponAndTotals
 * - Accepts basePrice (INCLUSIVE of GST) and couponCode
 * - Returns subtotal (base/inclusive), discount, taxable, gst, total
 */
function applyCouponAndTotals(basePrice, couponCode) {
  const inclusive = Number(basePrice);
  let discount = 0;
  let appliedCoupon = null;
  if (couponCode) {
    const c = COUPONS[couponCode];
    if (c) {
      if (c.type === "flat") {
        if (inclusive < (c.min || 0)) {
          return { error: `Coupon ${couponCode} requires minimum order \u20B9${c.min}.` };
        }
        discount = Number(c.amount || 0);
        appliedCoupon = c;
      } else if (c.type === "percent") {
        const raw = (inclusive * (Number(c.pct || 0) / 100));
        const capped = c.cap ? Math.min(raw, Number(c.cap)) : raw;
        discount = moneyRound(capped);
        appliedCoupon = c;
      } else {
        return { error: `Invalid coupon type for ${couponCode}.` };
      }
    } else {
      return { error: `Invalid coupon code.` };
    }
  }
  if (discount > inclusive) discount = inclusive;
  const total = moneyRound(inclusive - discount);
  // Taxable is total / (1 + GST_RATE)
  const taxableRaw = total / (1 + GST_RATE);
  const taxable = moneyRound(taxableRaw);
  const gst = moneyRound(total - taxable);
  return { subtotal: moneyRound(inclusive), discount: moneyRound(discount), taxable, gst, total, applied_coupon: appliedCoupon ? appliedCoupon.code : null };
}

// --- Helpers ---
function pathParts(url) {
  const u = new URL(url);
  return u.pathname.replace(/\/+$/, "").split("/").filter(Boolean);
}

function generateRefFromMember(memberId) {
  const alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const a = alpha.charCodeAt(memberId % alpha.length) || 65;
  const b = alpha.charCodeAt((memberId + 3) % alpha.length) || 65;
  const c = alpha.charCodeAt((memberId + 7) % alpha.length) || 65;
  const letters = String.fromCharCode(a, b, c);
  const numpart = String((memberId * 37 + 1234) % 10000).padStart(4, '0');
  const idpart = String(memberId).padStart(6, '0');
  return `${letters}${numpart}-${idpart}`;
}

function generateUniqueToken(len = 28) {
  // Cloudflare Workers provide a global crypto
  const bytes = new Uint8Array(Math.ceil(len * 0.75));
  crypto.getRandomValues(bytes);
  let s = '';
  for (let i = 0; i < bytes.length; i++) {
    s += bytes[i].toString(36);
  }
  return s.replace(/[^a-z0-9]/gi, '').slice(0, len);
}

function buildCompanyBlock() {
  return {
    name: "KenFolios Media Private Limited",
    address: "Second floor, F-328, Lado Sarai, New Delhi, Delhi, 110030",
    gstin: "07AAGCK7129K1Z7",
    cin: "U72900DL2017PTC321788"
  };
}

// --- Optional mailer webhook (fire-and-forget) ---
async function fireMailerWebhook(env, payload) {
  try {
    if (!env.MAILER_WEBHOOK) return;
    // Fire-and-forget: do not await (non-blocking). Any failure logged to console.
    fetch(env.MAILER_WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).catch(e => { console.error('Mailer webhook failed (fire-and-forget):', String(e)); });
  } catch (e) {
    console.error('Mailer webhook error:', String(e));
  }
}

// --- Worker entrypoint ---
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const origin = request.headers.get("Origin") || "*";

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders(origin) });
    }

    if (!env.D1_WRITE_BINDING) {
      return json({ ok: false, message: "D1 binding not found (env.D1_WRITE_BINDING)" }, 500, origin);
    }

    if (env.ALLOWED_ORIGINS && env.ALLOWED_ORIGINS.trim()) {
      const allowed = env.ALLOWED_ORIGINS.split(',').map(s => s.trim()).filter(Boolean);
      if (allowed.length && origin !== "*" && !allowed.includes(origin)) {
        return json({ ok: false, message: "Origin not allowed" }, 403, origin);
      }
    }

    const rawPath = url.pathname.replace(/\/+$/, "") || "/";

    try {
      if ((rawPath === "/api/join" || rawPath.endsWith("/api/join")) && request.method === "POST") {
        return await handleJoin(request, env, origin);
      }
      if (rawPath.startsWith("/api/member/") && request.method === "PATCH") {
        return await handlePatchMember(request, env, origin);
      }
      if ((rawPath === "/api/payment/create-order" || rawPath.endsWith("/api/payment/create-order")) && request.method === "POST") {
        return await handleCreateOrder(request, env, origin);
      }
      if ((rawPath === "/api/payment/confirm" || rawPath.endsWith("/api/payment/confirm")) && request.method === "POST") {
        return await handlePaymentConfirm(request, env, origin);
      }

      // --- NEW: endpoint to fetch order by ref_id (used by homepage loader) ---
      if ((rawPath === "/api/order/by-ref" || rawPath.endsWith("/api/order/by-ref")) && request.method === "POST") {
        return await handleFetchOrderByRef(request, env, origin);
      }
      // ----------------------------------------------------------------------
    } catch (err) {
      console.error("Unhandled error:", String(err));
      return json({ ok: false, message: "Internal error", error: String(err) }, 500, origin);
    }

    return json({ ok: false, message: "Not found" }, 404, origin);
  }
};

// ---------------- Handlers ----------------
async function parseJsonSafe(request) {
  const ct = (request.headers.get("content-type") || "").toLowerCase();
  if (ct.includes("application/json")) return await request.json();
  const txt = await request.text();
  try { return txt ? JSON.parse(txt) : {}; } catch { return {}; }
}

async function handleJoin(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const full_name = (body.name || body.fullName || body.full_name || "").toString().trim();
  const dob = (body.dob || "").toString().trim();
  const gender = (body.gender || "").toString().trim();
  const city = (body.city || "").toString().trim();
  const email = (body.email || "").toString().trim().toLowerCase();
  const phone = (body.phone || "").toString().trim();
  const expectations = Array.isArray(body.expectations) ? body.expectations.join(',') : (body.expectations || body.expect || "").toString();
  const accept = (body.accept || body.accepted || body.fi_accept) ? 1 : 0;
  const created_at = new Date().toISOString();

  if (!full_name || !dob || !gender || !city || !email || !phone) {
    return json({ ok: false, message: "Missing required fields (name,dob,gender,city,email,phone required)" }, 400, origin);
  }
  if (!/@/.test(email) || phone.length < 6) {
    return json({ ok: false, message: "Invalid email or phone" }, 400, origin);
  }

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE email = ? ORDER BY created_at DESC LIMIT 1").bind(email).all();
    if (lookup && lookup.results && lookup.results[0]) {
      const existing = lookup.results[0];
      if (existing.activation_fee_status === 'paid') {
        return json({ ok: false, message: "A membership is already active for this email. Please use a different email to register or contact support if this is your account.", reason: "already_paid" }, 409, origin);
      } else {
        const updateSql = `UPDATE members SET full_name = ?, dob = ?, gender = ?, city = ?, phone = ?, expectations = ?, accepted_terms = ? WHERE id = ?`;
        await db.prepare(updateSql)
          .bind(full_name, dob, gender, city, phone, expectations, accept ? 1 : 0, existing.id)
          .run();
        const order = buildOrderObject(existing.id, existing, null);
        const dbCount = await readMemberCountOrFallback(db);
        return json({ ok: true, member_id: Number(existing.id), dbCount, order }, 200, origin);
      }
    }

    // Insert new member
    let member_id = null;
    try {
      const insertSql = `INSERT INTO members (full_name, dob, gender, city, email, phone, expectations, accepted_terms, created_at, activation_fee_status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?) RETURNING id`;
      const insertRes = await db.prepare(insertSql)
        .bind(full_name, dob, gender, city, email, phone, expectations, accept ? 1 : 0, created_at, 'pending')
        .all();
      if (insertRes && insertRes.results && insertRes.results[0] && insertRes.results[0].id != null) {
        member_id = Number(insertRes.results[0].id);
      }
    } catch (insErr) {
      // fallback if RETURNING not supported
      try {
        const plainInsert = `INSERT INTO members (full_name, dob, gender, city, email, phone, expectations, accepted_terms, created_at, activation_fee_status) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;
        await db.prepare(plainInsert)
          .bind(full_name, dob, gender, city, email, phone, expectations, accept ? 1 : 0, created_at, 'pending')
          .run();
      } catch (plainErr) {
        throw plainErr;
      }
    }

    if (!member_id) {
      const byEmail = await db.prepare("SELECT id FROM members WHERE email = ? ORDER BY created_at DESC LIMIT 1").bind(email).all();
      if (byEmail && byEmail.results && byEmail.results[0] && byEmail.results[0].id != null) {
        member_id = Number(byEmail.results[0].id);
      }
    }

    try {
      const upsertCountSql = `INSERT INTO meta (key, value) VALUES ('member_count', '1') ON CONFLICT(key) DO UPDATE SET value = CAST(value AS INTEGER) + 1`;
      await db.prepare(upsertCountSql).run();
    } catch (upErr) {
      console.error("meta upsert failed:", String(upErr));
    }

    // --- AFTER INSERT: ensure stable ref_id + order_url are created immediately ---
    try {
      const order_ref = generateRefFromMember(member_id);
      // NEW: use query-param style order URL so CF Pages routing won't require a sub-folder
      const order_url = `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;
      await db.prepare(`UPDATE members SET ref_id = COALESCE(ref_id, ?), order_url = COALESCE(order_url, ?), activation_order_token = COALESCE(activation_order_token, ?) WHERE id = ?;`).bind(order_ref, order_url, order_ref, member_id).run();
    } catch (e) {
      console.error("Could not persist initial ref_id/order_url after join:", String(e));
    }

    const byId = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(member_id).all();
    const memberRow = (byId && byId.results && byId.results[0]) ? byId.results[0] : null;
    const order = buildOrderObject(member_id, memberRow, null);
    const dbCount = await readMemberCountOrFallback(db);
    return json({ ok: true, member_id, message: "Joined", dbCount, order }, 201, origin);

  } catch (err) {
    const errStr = String(err || '');
    console.error("DB write error:", errStr);
    if (errStr.toLowerCase().includes('unique') || errStr.toLowerCase().includes('constraint')) {
      return json({ ok: false, message: "Duplicate record (email may already exist)", error: errStr }, 409, origin);
    }
    return json({ ok: false, message: "DB write error", error: errStr }, 500, origin);
  }
}

async function handlePatchMember(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const parts = pathParts(request.url);
  const idPart = parts[parts.length - 1];
  const memberId = Number(idPart);
  if (!memberId) return json({ ok: false, message: "Missing member id" }, 400, origin);
  const body = await parseJsonSafe(request);
  const editableFields = {};
  if (body.name) editableFields.full_name = body.name.toString().trim();
  if (body.email) editableFields.email = body.email.toString().trim().toLowerCase();
  if (body.phone) editableFields.phone = body.phone.toString().trim();
  if (body.city) editableFields.city = body.city.toString().trim();
  if (editableFields.email && !/@/.test(editableFields.email)) {
    return json({ ok: false, message: "Invalid email" }, 400, origin);
  }
  if (editableFields.phone && editableFields.phone.length < 6) {
    return json({ ok: false, message: "Invalid phone" }, 400, origin);
  }

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(memberId).all();
    if (!lookup || !lookup.results || !lookup.results[0]) {
      return json({ ok: false, message: "Member not found" }, 404, origin);
    }
    const existing = lookup.results[0];
    if (existing.activation_fee_status === 'paid') {
      return json({ ok: false, message: "Member already paid; record is read-only", reason: "already_paid" }, 409, origin);
    }
    const keys = Object.keys(editableFields);
    if (keys.length === 0) {
      const order = buildOrderObject(memberId, existing, null);
      return json({ ok: true, member_id: memberId, order }, 200, origin);
    }
    const sets = keys.map(k => `${k} = ?`).join(", ");
    const bindVals = keys.map(k => editableFields[k]);
    bindVals.push(memberId);
    const updateSql = `UPDATE members SET ${sets} WHERE id = ?`;
    await db.prepare(updateSql).bind(...bindVals).run();
    const updated = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(memberId).all();
    const updatedRow = updated.results[0];
    const order = buildOrderObject(memberId, updatedRow, null);
    return json({ ok: true, member_id: memberId, order }, 200, origin);
  } catch (err) {
    console.error("Patch member error:", String(err));
    return json({ ok: false, message: "Update failed", error: String(err) }, 500, origin);
  }
}

async function handleCreateOrder(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const member_id = Number(body.member_id || body.memberId);
  const applyCoupon = (body.coupon || body.coupon_code || body.couponCode || null);
  const simulate = body.simulate || false;
  if (!member_id) { return json({ ok: false, message: "member_id required" }, 400, origin); }
  const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(member_id).all();
  if (!lookup || !lookup.results || !lookup.results[0]) { return json({ ok: false, message: "Member not found" }, 404, origin); }
  const member = lookup.results[0];
  if (member.activation_fee_status === 'paid') { return json({ ok: false, message: "Activation fee already paid for this member", reason: "already_paid" }, 409, origin); }
  const totalsRes = applyCouponAndTotals(BASE_PRODUCT.base_price, applyCoupon);
  if (totalsRes.error) { return json({ ok: false, message: totalsRes.error }, 400, origin); }

  // Persist activation_created_at as UNIX seconds for order_created_at
  try {
    const nowSec = Math.floor(Date.now() / 1000);
    await db.prepare("UPDATE members SET activation_created_at = COALESCE(activation_created_at, ?) WHERE id = ?;").bind(nowSec, member_id).run();
  } catch (upErr) {
    console.error("activation_created_at update failed:", String(upErr));
  }

  // Generate stable order_ref & order_url and persist (do not overwrite if exists)
  const order_ref = generateRefFromMember(member_id);
  // NEW: query-param style order URL to avoid subfolder routing issues on Cloudflare Pages
  const order_url = `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;
  try {
    await db.prepare(`UPDATE members SET ref_id = COALESCE(ref_id, ?), order_url = COALESCE(order_url, ?), activation_order_token = COALESCE(activation_order_token, ?) WHERE id = ?;`).bind(order_ref, order_url, order_ref, member_id).run();
  } catch (e) {
    console.error("Could not persist order_url/ref_id:", String(e));
  }

  // Re-fetch member after potential updates
  const afterSet = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(member_id).all();
  const memberAfter = (afterSet && afterSet.results && afterSet.results[0]) ? afterSet.results[0] : member;

  // If simulate -> return totals & order (no gateway interaction)
  if (simulate) {
    return json({ ok: true, razorpay_configured: !!(env.RAZORPAY_KEY_ID && env.RAZORPAY_KEY_SECRET), message: "Simulated order totals", order: buildOrderObject(member_id, memberAfter, totalsRes) }, 200, origin);
  }

  // If Razorpay not configured, still return created order (order_url present)
  if (!env.RAZORPAY_KEY_ID || !env.RAZORPAY_KEY_SECRET) {
    try {
      if (env.MAILER_WEBHOOK && memberAfter && memberAfter.email) {
        const payload = { type: 'order_created', email: memberAfter.email, member_id, order_ref, order_url, totals: totalsRes, timestamp: new Date().toISOString() };
        fireMailerWebhook(env, payload);
      }
    } catch (e) { console.error('mail webhook error (no-razorpay):', String(e)); }

    return json({ ok: true, razorpay_configured: false, message: "Payment options will appear here soon.", order: buildOrderObject(member_id, memberAfter, totalsRes) }, 200, origin);
  }

  // Create Razorpay order
  try {
    const createPayload = { amount: totalsRes.total * 100, currency: BASE_PRODUCT.currency, receipt: `ORDER-${order_ref}`, payment_capture: 1, notes: { member_id: String(member_id), order_ref } };
    // Use btoa for Basic auth
    const razorpayAuth = btoa(`${env.RAZORPAY_KEY_ID}:${env.RAZORPAY_KEY_SECRET}`);
    const rpRes = await fetch("https://api.razorpay.com/v1/orders", { method: "POST", headers: { "Content-Type": "application/json", "Authorization": `Basic ${razorpayAuth}` }, body: JSON.stringify(createPayload) });
    if (!rpRes.ok) {
      const txt = await rpRes.text();
      console.error("Razorpay create-order failed:", rpRes.status, txt);
      return json({ ok: false, message: "Failed to create payment order", razorpay_error: txt }, 502, origin);
    }
    const rpJson = await rpRes.json();

    // Persist gateway order id/meta if not already set
    try {
      await db.prepare(`UPDATE members SET activation_gateway_order_id = COALESCE(activation_gateway_order_id, ?), activation_gateway_meta = COALESCE(activation_gateway_meta, ?) WHERE id = ?;`).bind(rpJson.id || null, JSON.stringify(rpJson) || null, member_id).run();
    } catch (e) { console.error("Failed to persist gateway order id/meta:", String(e)); }

    // Fire mailer webhook for order created (non-blocking)
    try {
      if (env.MAILER_WEBHOOK && memberAfter && memberAfter.email) {
        const payload = { type: 'order_created', email: memberAfter.email, member_id, order_ref, order_url, razorpay_order: rpJson, totals: totalsRes, timestamp: new Date().toISOString() };
        fireMailerWebhook(env, payload);
      }
    } catch (e) { console.error('mail webhook error (after-rp):', String(e)); }

    return json({ ok: true, razorpay_configured: true, razorpay_order: rpJson, order: buildOrderObject(member_id, memberAfter, totalsRes) }, 200, origin);

  } catch (err) {
    console.error("Create-order error:", String(err));
    return json({ ok: false, message: "Payment order creation failed", error: String(err) }, 500, origin);
  }
}

async function handlePaymentConfirm(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const member_id = Number(body.member_id || body.memberId);
  const razorpayPaymentId = body.razorpay_payment_id || body.razorpayPaymentId || null;
  const razorpayOrderId = body.razorpay_order_id || body.razorpayOrderId || null;
  const razorpaySignature = body.razorpay_signature || body.razorpaySignature || null;
  const coupon = body.coupon || body.coupon_code || null;
  if (!member_id) return json({ ok: false, message: "member_id required" }, 400, origin);

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(member_id).all();
    if (!lookup || !lookup.results || !lookup.results[0]) { return json({ ok: false, message: "Member not found" }, 404, origin); }
    const member = lookup.results[0];
    if (member.activation_fee_status === 'paid') { return json({ ok: true, message: "Already marked paid", reason: "already_paid" }, 200, origin); }
    const totalsRes = applyCouponAndTotals(BASE_PRODUCT.base_price, coupon);
    if (totalsRes.error) { return json({ ok: false, message: totalsRes.error }, 400, origin); }
    const now = new Date().toISOString();

    const updateSql = `UPDATE members SET activation_fee_status = 'paid', activation_fee_amount = ?, activation_coupon_code = ?, activation_fee_paid_at = ?, payment_gateway = ?, payment_gateway_payment_id = ? WHERE id = ?`;
    await db.prepare(updateSql)
      .bind(totalsRes.total, coupon || null, now, "razorpay", razorpayPaymentId || null, member_id)
      .run();

    // Generate unique_token + activation_url if not already present
    let unique_token = null;
    try {
      const after = await db.prepare("SELECT unique_token, activation_url, ref_id, email FROM members WHERE id = ? LIMIT 1").bind(member_id).all();
      const existing = (after && after.results && after.results[0]) ? after.results[0] : null;
      unique_token = existing && existing.unique_token ? existing.unique_token : null;
      if (!unique_token) {
        unique_token = generateUniqueToken(28);
        const activation_url = `https://kenfolios.com/community/activation/${encodeURIComponent(unique_token)}`;
        await db.prepare(`UPDATE members SET unique_token = ?, activation_url = ?, activated_at = ? WHERE id = ?;`).bind(unique_token, activation_url, now, member_id).run();
      } else {
        // Ensure activation_url exists
        const activation_url = `https://kenfolios.com/community/activation/${encodeURIComponent(unique_token)}`;
        await db.prepare(`UPDATE members SET activation_url = COALESCE(activation_url, ?), activated_at = COALESCE(activated_at, ?) WHERE id = ?;`).bind(activation_url, now, member_id).run();
      }
    } catch (tErr) { console.error("Failed to set unique_token/activation_url:", String(tErr)); }

    // Optionally track coupon usage
    try {
      if (coupon) {
        const stamp = `${coupon}|${member_id}|${now}`;
        await db.prepare(`INSERT INTO meta (key, value) VALUES (?, ?) ON CONFLICT(key) DO UPDATE SET value = value || ',' || excluded.value;`).bind('coupon_usage', stamp).run().catch(()=>{});
      }
    } catch (cuErr) { /* ignore */ }

    // Re-fetch updated row
    const updated = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1").bind(member_id).all();
    const updatedRow = updated.results[0];
    const order = buildOrderObject(member_id, updatedRow, totalsRes);

    // Fire mailer webhook for activation (non-blocking)
    try {
      if (env.MAILER_WEBHOOK && (updatedRow.email || member.email)) {
        const payload = { type: 'activation', email: updatedRow.email || member.email, member_id, activation_url: updatedRow.activation_url || (`https://kenfolios.com/community/activation/${encodeURIComponent(unique_token)}`), order_ref: updatedRow.ref_id || null, totals: totalsRes, timestamp: new Date().toISOString() };
        fireMailerWebhook(env, payload);
      }
    } catch (e) { console.error('mail webhook error (activation):', String(e)); }

    // Optionally send activation webhook/email here
    return json({ ok: true, message: "Payment confirmed", member_id, order }, 200, origin);

  } catch (err) {
    console.error("Payment confirm error:", String(err));
    return json({ ok: false, message: "Payment confirmation failed", error: String(err) }, 500, origin);
  }
}

// ---------------- NEW handler: Fetch order by ref_id ----------------
async function handleFetchOrderByRef(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const ref_id = (body.ref_id || body.refId || '').toString().trim();
  if (!ref_id) { return json({ ok: false, message: "ref_id required" }, 400, origin); }
  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE ref_id = ? LIMIT 1").bind(ref_id).all();
    if (!lookup || !lookup.results || !lookup.results[0]) {
      console.warn('handleFetchOrderByRef: not found', ref_id);
      return json({ ok: false, message: "Order not found" }, 404, origin);
    }
    const member = lookup.results[0];
    const order = buildOrderObject(member.id, member, null);
    return json({ ok: true, order }, 200, origin);
  } catch (err) {
    console.error('handleFetchOrderByRef error:', String(err));
    return json({ ok: false, message: "Internal error" }, 500, origin);
  }
}

// -------------------------------------------------------------------
// ---------------- Order builder & helpers ----------------
function buildOrderObject(memberId, memberRow, totalsOverride) {
  const member = memberRow ? { id: memberRow.id, full_name: memberRow.full_name, email: memberRow.email, phone: memberRow.phone, city: memberRow.city, dob: memberRow.dob, gender: memberRow.gender, expectations: memberRow.expectations } : {};
  const order_ref = memberRow && memberRow.ref_id ? memberRow.ref_id : generateRefFromMember(memberId);
  const totals = totalsOverride ? totalsOverride : applyCouponAndTotals(BASE_PRODUCT.base_price, memberRow && memberRow.activation_coupon_code ? memberRow.activation_coupon_code : null);
  const status = (memberRow && memberRow.activation_fee_status === 'paid') ? 'paid' : 'pending';
  const editable = status !== 'paid';
  const available_coupons = Object.values(COUPONS).map(c => ({ code: c.code, type: c.type, amount: c.amount || null, pct: c.pct || null, cap: c.cap || null, min: c.min || 0 }));

  // Build order_created_at: prefer activation_created_at (UNIX secs), else created_at ISO, else now
  let order_created_at = null;
  if (memberRow && memberRow.activation_created_at) {
    try { const sec = Number(memberRow.activation_created_at); if (!isNaN(sec)) order_created_at = new Date(sec * 1000).toISOString(); } catch (e) {}
  }
  if (!order_created_at && memberRow && memberRow.created_at) { order_created_at = (new Date(memberRow.created_at)).toISOString(); }
  if (!order_created_at) order_created_at = (new Date()).toISOString();

  // Ensure order_url uses query param style
  const order_url = memberRow && memberRow.order_url ? memberRow.order_url : `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;
  const activation_url = memberRow && memberRow.activation_url ? memberRow.activation_url : (memberRow && memberRow.unique_token ? `https://kenfolios.com/community/activation/${encodeURIComponent(memberRow.unique_token)}` : null);

  return {
    order_ref,
    order_created_at,
    order_url,
    activation_url,
    ref_id: order_ref,
    member: member,
    product: { name: BASE_PRODUCT.name, base_price: BASE_PRODUCT.base_price, currency: BASE_PRODUCT.currency },
    available_coupons,
    applied_coupon: totals.applied_coupon || null,
    totals: { subtotal: totals.subtotal, discount: totals.discount, taxable: totals.taxable, gst: totals.gst, total: totals.total },
    status,
    editable,
    company: buildCompanyBlock()
  };
}

async function readMemberCountOrFallback(db) {
  try {
    const metaRes = await db.prepare("SELECT value FROM meta WHERE key = 'member_count' LIMIT 1").all();
    if (metaRes && metaRes.results && metaRes.results[0] && metaRes.results[0].value != null) {
      return Number(metaRes.results[0].value) || 0;
    } else {
      const cntRes = await db.prepare("SELECT COUNT(*) AS cnt FROM members").all();
      if (cntRes && cntRes.results && cntRes.results[0] && cntRes.results[0].cnt != null) {
        return Number(cntRes.results[0].cnt) || 0;
      }
    }
  } catch (err) { console.error("count read failed:", String(err)); }
  return null;
}
