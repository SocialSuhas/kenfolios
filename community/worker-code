
/**
 * kf-members-submit-z9p4x-worker â€” complete
 * - Generates & persists order_url/ref_id on create-order and on initial join
 * - Generates & persists unique_token/activation_url on payment confirm
 * - BASE_PRODUCT is GST-inclusive (1999 INR)
 * - Optional MAILER_WEBHOOK env: receives JSON payloads for order_created and activation events
 *
 * Bindings required:
 * env.D1_WRITE_BINDING (Cloudflare D1)
 *
 * Optional env vars:
 * env.RAZORPAY_KEY_ID
 * env.RAZORPAY_KEY_SECRET
 * env.ALLOWED_ORIGINS
 * env.MAILER_WEBHOOK
 *
 * Telegram-related env vars:
 * env.TELEGRAM_BOT_TOKEN            // Bot token from BotFather
 * env.TELEGRAM_WEBHOOK_SECRET       // Secret used in setWebhook secret_token
 * env.TELEGRAM_GROUP_ID             // Optional: numeric group ID (if needed later)
 * env.TELEGRAM_GROUP_INVITE_LINK    // Recommended: permanent invite link to the group
 */

const JSON_HEADERS = { "Content-Type": "application/json; charset=utf-8" };

function corsHeaders(origin) {
  return {
    "Access-Control-Allow-Origin": origin || "*",
    "Access-Control-Allow-Methods": "GET,POST,PATCH,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type,Accept"
  };
}

function json(body, status = 200, origin = "*") {
  return new Response(JSON.stringify(body), {
    status,
    headers: { ...JSON_HEADERS, ...corsHeaders(origin) }
  });
}

// --- Product / tax config (server authoritative) ---
const BASE_PRODUCT = {
  name: "Activation fee",
  base_price: 1999,
  currency: "INR",
  inclusive_gst: true
};
const GST_RATE = 0.18;

// --- Coupon definitions (server authoritative) ---
const COUPONS = {
  "KEN100": { code: "KEN100", type: "flat", amount: 100, min: 0, stackable: false },
  "VSTREET20": { code: "VSTREET20", type: "percent", pct: 20, cap: 400, min: 0, stackable: false },
  "LAUNCH500": { code: "LAUNCH500", type: "flat", amount: 500, min: 1499, stackable: false }
};

function moneyRound(n) { return Math.round(n); }

/**
 * applyCouponAndTotals
 * - Accepts basePrice (INCLUSIVE of GST) and couponCode
 * - Returns subtotal (base/inclusive), discount, taxable, gst, total
 */
function applyCouponAndTotals(basePrice, couponCode) {
  const inclusive = Number(basePrice);
  let discount = 0;
  let appliedCoupon = null;
  if (couponCode) {
    const c = COUPONS[couponCode];
    if (c) {
      if (c.type === "flat") {
        if (inclusive < (c.min || 0)) {
          return { error: `Coupon ${couponCode} requires minimum order \u20B9${c.min}.` };
        }
        discount = Number(c.amount || 0);
        appliedCoupon = c;
      } else if (c.type === "percent") {
        const raw = (inclusive * (Number(c.pct || 0) / 100));
        const capped = c.cap ? Math.min(raw, Number(c.cap)) : raw;
        discount = moneyRound(capped);
        appliedCoupon = c;
      } else {
        return { error: `Invalid coupon type for ${couponCode}.` };
      }
    } else {
      return { error: `Invalid coupon code.` };
    }
  }
  if (discount > inclusive) discount = inclusive;
  const total = moneyRound(inclusive - discount);
  // Taxable is total / (1 + GST_RATE)
  const taxableRaw = total / (1 + GST_RATE);
  const taxable = moneyRound(taxableRaw);
  const gst = moneyRound(total - taxable);
  return {
    subtotal: moneyRound(inclusive),
    discount: moneyRound(discount),
    taxable,
    gst,
    total,
    applied_coupon: appliedCoupon ? appliedCoupon.code : null
  };
}

// --- Helpers ---
function pathParts(url) {
  const u = new URL(url);
  return u.pathname.replace(/\/+$/, "").split("/").filter(Boolean);
}

function generateRefFromMember(memberId) {
  const alpha = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const a = alpha.charCodeAt(memberId % alpha.length) || 65;
  const b = alpha.charCodeAt((memberId + 3) % alpha.length) || 65;
  const c = alpha.charCodeAt((memberId + 7) % alpha.length) || 65;
  const letters = String.fromCharCode(a, b, c);
  const numpart = String((memberId * 37 + 1234) % 10000).padStart(4, '0');
  const idpart = String(memberId).padStart(6, '0');
  return `${letters}${numpart}-${idpart}`;
}

function generateUniqueToken(len = 28) {
  // Cloudflare Workers provide a global crypto
  const bytes = new Uint8Array(Math.ceil(len * 0.75));
  crypto.getRandomValues(bytes);
  let s = '';
  for (let i = 0; i < bytes.length; i++) {
    s += bytes[i].toString(36);
  }
  return s.replace(/[^a-z0-9]/gi, '').slice(0, len);
}

// --- Razorpay signature helper (HMAC SHA256) ---
async function hmacSHA256Hex(secret, message) {
  const enc = new TextEncoder();
  const keyData = enc.encode(secret);
  const msgData = enc.encode(message);

  const cryptoKey = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );

  const sigBuf = await crypto.subtle.sign("HMAC", cryptoKey, msgData);
  const bytes = new Uint8Array(sigBuf);
  let hex = "";
  for (let i = 0; i < bytes.length; i++) {
    hex += bytes[i].toString(16).padStart(2, "0");
  }
  return hex;
}

async function verifyRazorpaySignature(secret, orderId, paymentId, signature) {
  if (!secret) return false;
  if (!orderId || !paymentId || !signature) return false;
  const payload = `${orderId}|${paymentId}`;
  const computed = await hmacSHA256Hex(secret, payload);
  return computed === signature;
}

function buildCompanyBlock() {
  return {
    name: "KenFolios Media Private Limited",
    address: "Second floor, F-328, Lado Sarai, New Delhi, Delhi, 110030",
    gstin: "07AAGCK7129K1Z7",
    cin: "U72900DL2017PTC321788"
  };
}

// --- Optional mailer webhook (fire-and-forget) ---
async function fireMailerWebhook(env, payload) {
  try {
    if (!env.MAILER_WEBHOOK) return;
    // Fire-and-forget: do not await (non-blocking). Any failure logged to console.
    fetch(env.MAILER_WEBHOOK, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }).catch(e => {
      console.error('Mailer webhook failed (fire-and-forget):', String(e));
    });
  } catch (e) {
    console.error('Mailer webhook error:', String(e));
  }
}

// --- Worker entrypoint ---
export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const origin = request.headers.get("Origin") || "*";
    const rawPath = url.pathname.replace(/\/+$/, "") || "/";
    const isTelegramWebhookPath =
      rawPath === "/api/telegram/webhook" || rawPath.endsWith("/api/telegram/webhook");

    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders(origin) });
    }

    if (!env.D1_WRITE_BINDING) {
      return json({ ok: false, message: "D1 binding not found (env.D1_WRITE_BINDING)" }, 500, origin);
    }

    // Apply ALLOWED_ORIGINS check for browser/API calls, but NOT for Telegram webhook
    if (!isTelegramWebhookPath && env.ALLOWED_ORIGINS && env.ALLOWED_ORIGINS.trim()) {
      const allowed = env.ALLOWED_ORIGINS.split(',').map(s => s.trim()).filter(Boolean);
      if (allowed.length && origin !== "*" && !allowed.includes(origin)) {
        return json({ ok: false, message: "Origin not allowed" }, 403, origin);
      }
    }

    try {
      if ((rawPath === "/api/join" || rawPath.endsWith("/api/join")) && request.method === "POST") {
        return await handleJoin(request, env, origin);
      }
      if (rawPath.startsWith("/api/member/") && request.method === "PATCH") {
        return await handlePatchMember(request, env, origin);
      }
      if ((rawPath === "/api/payment/create-order" || rawPath.endsWith("/api/payment/create-order")) && request.method === "POST") {
        return await handleCreateOrder(request, env, origin);
      }
      if ((rawPath === "/api/payment/confirm" || rawPath.endsWith("/api/payment/confirm")) && request.method === "POST") {
        return await handlePaymentConfirm(request, env, origin);
      }
      // NEW: v2 confirm endpoint that uses activation_* columns only and verifies signature
      if ((rawPath === "/api/payment/confirm-v2" || rawPath.endsWith("/api/payment/confirm-v2")) && request.method === "POST") {
        return await handlePaymentConfirmV2(request, env, origin);
      }

      // --- NEW: endpoint to fetch order by ref_id (used by homepage loader) ---
      if ((rawPath === "/api/order/by-ref" || rawPath.endsWith("/api/order/by-ref")) && request.method === "POST") {
        return await handleFetchOrderByRef(request, env, origin);
      }

      // -----------------------------------------------
      // Telegram Webhook Endpoint â€” Activation Logic
      // -----------------------------------------------
      if (
        (rawPath === "/api/telegram/webhook" || rawPath.endsWith("/api/telegram/webhook")) &&
        request.method === "POST"
      ) {
        // Verify webhook secret (set via setWebhook & TELEGRAM_WEBHOOK_SECRET)
        const tgSecret = request.headers.get("X-Telegram-Bot-Api-Secret-Token") || "";
        if (env.TELEGRAM_WEBHOOK_SECRET && tgSecret !== env.TELEGRAM_WEBHOOK_SECRET) {
          return new Response("Unauthorized", { status: 401 });
        }

        let update = {};
        try {
          update = await request.json();
        } catch (e) {
          console.error("Telegram webhook JSON parse error:", e);
          return new Response("Bad request", { status: 400 });
        }

        console.log("Telegram update received:", JSON.stringify(update));

        const db = env.D1_WRITE_BINDING;
        const BOT_TOKEN = env.TELEGRAM_BOT_TOKEN;
        const GROUP_ID = env.TELEGRAM_GROUP_ID;
        const INVITE_LINK = env.TELEGRAM_GROUP_INVITE_LINK || null; // recommended: set this in env

        // Helper: call Telegram API
        async function callTelegram(method, payload) {
          if (!BOT_TOKEN) {
            console.error("TELEGRAM_BOT_TOKEN missing");
            return null;
          }
          try {
            const res = await fetch(`https://api.telegram.org/bot${BOT_TOKEN}/${method}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload)
            });
            const j = await res.json().catch(() => ({}));
            if (!res.ok || !j.ok) {
              console.error("Telegram API error", method, res.status, JSON.stringify(j));
            }
            return j;
          } catch (e) {
            console.error("Telegram API fetch error", method, String(e));
            return null;
          }
        }

        // Helper: send a DM to a user
        async function sendDM(chatId, text) {
          if (!BOT_TOKEN || !chatId) return;
          return await callTelegram("sendMessage", {
            chat_id: chatId,
            text: text,
            parse_mode: "HTML",
            disable_web_page_preview: true
          });
        }

        // We only handle private messages with /start <token>
        const msg = update.message || update.edited_message || null;
        if (!msg || !msg.from || !msg.chat || msg.chat.type !== "private") {
          // Not a private chat message â€” just ack
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        const from = msg.from;
        const chatId = msg.chat.id;
        const username = from.username || null;
        const telegramUserId = from.id;

        const text = (msg.text || "").trim();
        if (!text.startsWith("/start")) {
          // Optional: small helper reply
          await sendDM(
            chatId,
            "Please use the activation link from your browser so we can connect your membership to Telegram."
          );
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        // /start or /start <token>
        const parts = text.split(/\s+/);
        const activationToken = (parts[1] || "").trim();

        if (!activationToken) {
          await sendDM(
            chatId,
            "This activation link is incomplete. Please tap the activation button from your browser again."
          );
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        // Look up member by unique_token
        let memberRow = null;
        try {
          const res = await db
            .prepare("SELECT * FROM members WHERE unique_token = ? LIMIT 1")
            .bind(activationToken)
            .all();
          if (res && res.results && res.results[0]) {
            memberRow = res.results[0];
          }
        } catch (e) {
          console.error("D1 lookup error (unique_token):", String(e));
        }

        if (!memberRow) {
          await sendDM(
            chatId,
            "This activation link is invalid or expired. Please contact support if you believe this is an error."
          );
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        // Check payment status
        if (memberRow.activation_fee_status !== "paid") {
          await sendDM(
            chatId,
            "Your activation fee is not marked as paid yet. If you have already paid, please wait a minute and try again, or contact support."
          );
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        // Enforce one-telegram-user-per-token
        if (memberRow.telegram_user_id && Number(memberRow.telegram_user_id) !== Number(telegramUserId)) {
          await sendDM(
            chatId,
            "This activation link is already linked to another Telegram account. Please contact support if this is unexpected."
          );
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        const nowIso = new Date().toISOString();

        // Update member with Telegram details
        try {
          await db.prepare(`
            UPDATE members
            SET
              telegram_user_id = ?,
              telegram_username = ?,
              telegram_linked_at = ?,
              telegram_revoked_at = NULL,
              telegram_revocation_reason = NULL
            WHERE id = ?;
          `).bind(
            String(telegramUserId),
            username,
            nowIso,
            memberRow.id
          ).run();
        } catch (e) {
          console.error("D1 update error (telegram_*):", String(e));
          await sendDM(
            chatId,
            "We could not connect your Telegram right now. Please try again in a bit."
          );
          return new Response(JSON.stringify({ ok: true }), {
            status: 200,
            headers: { "Content-Type": "application/json" }
          });
        }

        // Try to give user access to the group
        if (!GROUP_ID && !INVITE_LINK) {
          await sendDM(
            chatId,
            "Your activation is confirmed, but the group link is not configured yet. Please contact support."
          );
        } else {
          if (INVITE_LINK) {
            // Recommended path: send invite link
            await sendDM(
              chatId,
              `ðŸŽ‰ <b>Activation successful!</b>\n\nYour membership is active.\n\nTap here to join the KenFolios Business Community:\n${INVITE_LINK}`
            );
          } else if (GROUP_ID) {
            // Fallback message if only GROUP_ID is set (no direct add API used here)
            await sendDM(
              chatId,
              "ðŸŽ‰ <b>Activation successful!</b>\n\nYour membership is active. Please contact support to receive the latest group link."
            );
          }
        }

        return new Response(JSON.stringify({ ok: true }), {
          status: 200,
          headers: { "Content-Type": "application/json" }
        });
      }

      // ----------------------------------------------------------------------
    } catch (err) {
      console.error("Unhandled error:", String(err));
      return json({ ok: false, message: "Internal error", error: String(err) }, 500, origin);
    }

    return json({ ok: false, message: "Not found" }, 404, origin);
  }
};

// ---------------- Handlers ----------------
async function parseJsonSafe(request) {
  const ct = (request.headers.get("content-type") || "").toLowerCase();
  if (ct.includes("application/json")) return await request.json();
  const txt = await request.text();
  try { return txt ? JSON.parse(txt) : {}; } catch { return {}; }
}

async function handleJoin(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const full_name = (body.name || body.fullName || body.full_name || "").toString().trim();
  const dob = (body.dob || "").toString().trim();
  const gender = (body.gender || "").toString().trim();
  const city = (body.city || "").toString().trim();
  const email = (body.email || "").toString().trim().toLowerCase();
  const phone = (body.phone || "").toString().trim();
  const expectations = Array.isArray(body.expectations)
    ? body.expectations.join(',')
    : (body.expectations || body.expect || "").toString();
  const accept = (body.accept || body.accepted || body.fi_accept) ? 1 : 0;
  const created_at = new Date().toISOString();

  if (!full_name || !dob || !gender || !city || !email || !phone) {
    return json({ ok: false, message: "Missing required fields (name,dob,gender,city,email,phone required)" }, 400, origin);
  }
  if (!/@/.test(email) || phone.length < 6) {
    return json({ ok: false, message: "Invalid email or phone" }, 400, origin);
  }

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE email = ? ORDER BY created_at DESC LIMIT 1")
      .bind(email).all();
    if (lookup && lookup.results && lookup.results[0]) {
      const existing = lookup.results[0];
      if (existing.activation_fee_status === 'paid') {
        return json({
          ok: false,
          message: "A membership is already active for this email. Please use a different email to register or contact support if this is your account.",
          reason: "already_paid"
        }, 409, origin);
      } else {
        const updateSql = `
          UPDATE members
          SET full_name = ?, dob = ?, gender = ?, city = ?, phone = ?, expectations = ?, accepted_terms = ?
          WHERE id = ?
        `;
        await db.prepare(updateSql)
          .bind(full_name, dob, gender, city, phone, expectations, accept ? 1 : 0, existing.id)
          .run();
        const order = buildOrderObject(existing.id, existing, null);
        const dbCount = await readMemberCountOrFallback(db);
        return json({ ok: true, member_id: Number(existing.id), dbCount, order }, 200, origin);
      }
    }

    // Insert new member
    let member_id = null;
    try {
      const insertSql = `
        INSERT INTO members
          (full_name, dob, gender, city, email, phone, expectations, accepted_terms, created_at, activation_fee_status)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        RETURNING id
      `;
      const insertRes = await db.prepare(insertSql)
        .bind(full_name, dob, gender, city, email, phone, expectations, accept ? 1 : 0, created_at, 'pending')
        .all();
      if (insertRes && insertRes.results && insertRes.results[0] && insertRes.results[0].id != null) {
        member_id = Number(insertRes.results[0].id);
      }
    } catch (insErr) {
      // fallback if RETURNING not supported
      try {
        const plainInsert = `
          INSERT INTO members
            (full_name, dob, gender, city, email, phone, expectations, accepted_terms, created_at, activation_fee_status)
          VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `;
        await db.prepare(plainInsert)
          .bind(full_name, dob, gender, city, email, phone, expectations, accept ? 1 : 0, created_at, 'pending')
          .run();
      } catch (plainErr) {
        throw plainErr;
      }
    }

    if (!member_id) {
      const byEmail = await db.prepare("SELECT id FROM members WHERE email = ? ORDER BY created_at DESC LIMIT 1")
        .bind(email).all();
      if (byEmail && byEmail.results && byEmail.results[0] && byEmail.results[0].id != null) {
        member_id = Number(byEmail.results[0].id);
      }
    }

    try {
      const upsertCountSql = `
        INSERT INTO meta (key, value) VALUES ('member_count', '1')
        ON CONFLICT(key) DO UPDATE SET value = CAST(value AS INTEGER) + 1
      `;
      await db.prepare(upsertCountSql).run();
    } catch (upErr) {
      console.error("meta upsert failed:", String(upErr));
    }

    // --- AFTER INSERT: ensure stable ref_id + order_url are created immediately ---
    try {
      const order_ref = generateRefFromMember(member_id);
      const order_url = `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;
      await db.prepare(`
        UPDATE members
        SET
          ref_id = COALESCE(ref_id, ?),
          order_url = COALESCE(order_url, ?),
          activation_order_token = COALESCE(activation_order_token, ?)
        WHERE id = ?;
      `).bind(order_ref, order_url, order_ref, member_id).run();
    } catch (e) {
      console.error("Could not persist initial ref_id/order_url after join:", String(e));
    }

    const byId = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(member_id).all();
    const memberRow = (byId && byId.results && byId.results[0]) ? byId.results[0] : null;
    const order = buildOrderObject(member_id, memberRow, null);
    const dbCount = await readMemberCountOrFallback(db);
    return json({ ok: true, member_id, message: "Joined", dbCount, order }, 201, origin);

  } catch (err) {
    const errStr = String(err || '');
    console.error("DB write error:", errStr);
    if (errStr.toLowerCase().includes('unique') || errStr.toLowerCase().includes('constraint')) {
      return json({
        ok: false,
        message: "Duplicate record (email may already exist)",
        error: errStr
      }, 409, origin);
    }
    return json({ ok: false, message: "DB write error", error: errStr }, 500, origin);
  }
}

async function handlePatchMember(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const parts = pathParts(request.url);
  const idPart = parts[parts.length - 1];
  const memberId = Number(idPart);
  if (!memberId) return json({ ok: false, message: "Missing member id" }, 400, origin);
  const body = await parseJsonSafe(request);
  const editableFields = {};
  if (body.name) editableFields.full_name = body.name.toString().trim();
  if (body.email) editableFields.email = body.email.toString().trim().toLowerCase();
  if (body.phone) editableFields.phone = body.phone.toString().trim();
  if (body.city) editableFields.city = body.city.toString().trim();
  if (editableFields.email && !/@/.test(editableFields.email)) {
    return json({ ok: false, message: "Invalid email" }, 400, origin);
  }
  if (editableFields.phone && editableFields.phone.length < 6) {
    return json({ ok: false, message: "Invalid phone" }, 400, origin);
  }

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(memberId).all();
    if (!lookup || !lookup.results || !lookup.results[0]) {
      return json({ ok: false, message: "Member not found" }, 404, origin);
    }
    const existing = lookup.results[0];
    if (existing.activation_fee_status === 'paid') {
      return json({
        ok: false,
        message: "Member already paid; record is read-only",
        reason: "already_paid"
      }, 409, origin);
    }
    const keys = Object.keys(editableFields);
    if (keys.length === 0) {
      const order = buildOrderObject(memberId, existing, null);
      return json({ ok: true, member_id: memberId, order }, 200, origin);
    }
    const sets = keys.map(k => `${k} = ?`).join(", ");
    const bindVals = keys.map(k => editableFields[k]);
    bindVals.push(memberId);
    const updateSql = `UPDATE members SET ${sets} WHERE id = ?`;
    await db.prepare(updateSql).bind(...bindVals).run();
    const updated = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(memberId).all();
    const updatedRow = updated.results[0];
    const order = buildOrderObject(memberId, updatedRow, null);
    return json({ ok: true, member_id: memberId, order }, 200, origin);
  } catch (err) {
    console.error("Patch member error:", String(err));
    return json({ ok: false, message: "Update failed", error: String(err) }, 500, origin);
  }
}

async function handleCreateOrder(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const member_id = Number(body.member_id || body.memberId);
  const applyCoupon = (body.coupon || body.coupon_code || body.couponCode || null);
  const simulate = body.simulate || false;
  if (!member_id) {
    return json({ ok: false, message: "member_id required" }, 400, origin);
  }
  const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
    .bind(member_id).all();
  if (!lookup || !lookup.results || !lookup.results[0]) {
    return json({ ok: false, message: "Member not found" }, 404, origin);
  }
  const member = lookup.results[0];
  if (member.activation_fee_status === 'paid') {
    return json({
      ok: false,
      message: "Activation fee already paid for this member",
      reason: "already_paid"
    }, 409, origin);
  }
  const totalsRes = applyCouponAndTotals(BASE_PRODUCT.base_price, applyCoupon);
  if (totalsRes.error) {
    return json({ ok: false, message: totalsRes.error }, 400, origin);
  }

  // Persist activation_created_at as UNIX seconds for order_created_at
  try {
    const nowSec = Math.floor(Date.now() / 1000);
    await db.prepare(`
      UPDATE members
      SET activation_created_at = COALESCE(activation_created_at, ?)
      WHERE id = ?;
    `).bind(nowSec, member_id).run();
  } catch (upErr) {
    console.error("activation_created_at update failed:", String(upErr));
  }

  // Generate stable order_ref & order_url and persist (do not overwrite if exists)
  const order_ref = generateRefFromMember(member_id);
  const order_url = `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;
  try {
    await db.prepare(`
      UPDATE members
      SET
        ref_id = COALESCE(ref_id, ?),
        order_url = COALESCE(order_url, ?),
        activation_order_token = COALESCE(activation_order_token, ?)
      WHERE id = ?;
    `).bind(order_ref, order_url, order_ref, member_id).run();
  } catch (e) {
    console.error("Could not persist order_url/ref_id:", String(e));
  }

  // Re-fetch member after potential updates
  const afterSet = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
    .bind(member_id).all();
  const memberAfter = (afterSet && afterSet.results && afterSet.results[0]) ? afterSet.results[0] : member;

  // If simulate -> return totals & order (no gateway interaction)
  if (simulate) {
    return json({
      ok: true,
      razorpay_configured: !!(env.RAZORPAY_KEY_ID && env.RAZORPAY_KEY_SECRET),
      message: "Simulated order totals",
      order: buildOrderObject(member_id, memberAfter, totalsRes)
    }, 200, origin);
  }

  // If Razorpay not configured, still return created order (order_url present)
  if (!env.RAZORPAY_KEY_ID || !env.RAZORPAY_KEY_SECRET) {
    try {
      if (env.MAILER_WEBHOOK && memberAfter && memberAfter.email) {
        const payload = {
          type: 'order_created',
          email: memberAfter.email,
          member_id,
          order_ref,
          order_url,
          totals: totalsRes,
          timestamp: new Date().toISOString()
        };
        fireMailerWebhook(env, payload);
      }
    } catch (e) {
      console.error('mail webhook error (no-razorpay):', String(e));
    }

    return json({
      ok: true,
      razorpay_configured: false,
      message: "Payment options will appear here soon.",
      order: buildOrderObject(member_id, memberAfter, totalsRes)
    }, 200, origin);
  }

  // Create Razorpay order
  try {
    const createPayload = {
      amount: totalsRes.total * 100,
      currency: BASE_PRODUCT.currency,
      receipt: `ORDER-${order_ref}`,
      payment_capture: 1,
      notes: { member_id: String(member_id), order_ref }
    };
    const razorpayAuth = btoa(`${env.RAZORPAY_KEY_ID}:${env.RAZORPAY_KEY_SECRET}`);
    const rpRes = await fetch("https://api.razorpay.com/v1/orders", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Basic ${razorpayAuth}`
      },
      body: JSON.stringify(createPayload)
    });
    if (!rpRes.ok) {
      const txt = await rpRes.text();
      console.error("Razorpay create-order failed:", rpRes.status, txt);
      return json({
        ok: false,
        message: "Failed to create payment order",
        razorpay_error: txt
      }, 502, origin);
    }
    const rpJson = await rpRes.json();

    // Persist gateway order id/meta if not already set
    try {
      await db.prepare(`
        UPDATE members
        SET
          activation_gateway_order_id = COALESCE(activation_gateway_order_id, ?),
          activation_gateway_meta = COALESCE(activation_gateway_meta, ?)
        WHERE id = ?;
      `).bind(rpJson.id || null, JSON.stringify(rpJson) || null, member_id).run();
    } catch (e) {
      console.error("Failed to persist gateway order id/meta:", String(e));
    }

    // Fire mailer webhook for order created (non-blocking)
    try {
      if (env.MAILER_WEBHOOK && memberAfter && memberAfter.email) {
        const payload = {
          type: 'order_created',
          email: memberAfter.email,
          member_id,
          order_ref,
          order_url,
          razorpay_order: rpJson,
          totals: totalsRes,
          timestamp: new Date().toISOString()
        };
        fireMailerWebhook(env, payload);
      }
    } catch (e) {
      console.error('mail webhook error (after-rp):', String(e));
    }

    return json({
      ok: true,
      razorpay_configured: true,
      razorpay_key_id: env.RAZORPAY_KEY_ID,
      razorpay_order: rpJson,
      order: buildOrderObject(member_id, memberAfter, totalsRes)
    }, 200, origin);

  } catch (err) {
    console.error("Create-order error:", String(err));
    return json({
      ok: false,
      message: "Payment order creation failed",
      error: String(err)
    }, 500, origin);
  }
}

async function handlePaymentConfirm(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const member_id = Number(body.member_id || body.memberId);
  const razorpayPaymentId = body.razorpay_payment_id || body.razorpayPaymentId || null;
  const razorpayOrderId = body.razorpay_order_id || body.razorpayOrderId || null;
  const razorpaySignature = body.razorpay_signature || body.razorpaySignature || null;
  const coupon = body.coupon || body.coupon_code || null;
  if (!member_id) return json({ ok: false, message: "member_id required" }, 400, origin);

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(member_id).all();
    if (!lookup || !lookup.results || !lookup.results[0]) {
      return json({ ok: false, message: "Member not found" }, 404, origin);
    }
    const member = lookup.results[0];
    if (member.activation_fee_status === 'paid') {
      return json({ ok: true, message: "Already marked paid", reason: "already_paid" }, 200, origin);
    }
    const totalsRes = applyCouponAndTotals(BASE_PRODUCT.base_price, coupon);
    if (totalsRes.error) {
      return json({ ok: false, message: totalsRes.error }, 400, origin);
    }
    const now = new Date().toISOString();

    // NOTE: This handler still uses payment_gateway/payment_gateway_payment_id,
    // which are not in your schema. Prefer using /api/payment/confirm-v2 instead.
    const updateSql = `
      UPDATE members
      SET
        activation_fee_status = 'paid',
        activation_fee_amount = ?,
        activation_coupon_code = ?,
        activation_fee_paid_at = ?,
        payment_gateway = ?,
        payment_gateway_payment_id = ?
      WHERE id = ?
    `;
    await db.prepare(updateSql)
      .bind(totalsRes.total, coupon || null, now, "razorpay", razorpayPaymentId || null, member_id)
      .run();

    // Generate unique_token + activation_url if not already present
    let unique_token = null;
    try {
      const after = await db.prepare("SELECT unique_token, activation_url, ref_id, email FROM members WHERE id = ? LIMIT 1")
        .bind(member_id).all();
      const existing = (after && after.results && after.results[0]) ? after.results[0] : null;
      unique_token = existing && existing.unique_token ? existing.unique_token : null;
      if (!unique_token) {
        unique_token = generateUniqueToken(28);
        const activation_url = `https://kenfolios.com/community?activation=${encodeURIComponent(unique_token)}`;
        await db.prepare(`
          UPDATE members
          SET unique_token = ?, activation_url = ?, activated_at = ?
          WHERE id = ?;
        `).bind(unique_token, activation_url, now, member_id).run();
      } else {
        const activation_url = `https://kenfolios.com/community?activation=${encodeURIComponent(unique_token)}`;
        await db.prepare(`
          UPDATE members
          SET
            activation_url = COALESCE(activation_url, ?),
            activated_at = COALESCE(activated_at, ?)
          WHERE id = ?;
        `).bind(activation_url, now, member_id).run();
      }
    } catch (tErr) {
      console.error("Failed to set unique_token/activation_url:", String(tErr));
    }

    // Optionally track coupon usage
    try {
      if (coupon) {
        const stamp = `${coupon}|${member_id}|${now}`;
        await db.prepare(`
          INSERT INTO meta (key, value)
          VALUES (?, ?)
          ON CONFLICT(key) DO UPDATE SET value = value || ',' || excluded.value;
        `).bind('coupon_usage', stamp).run().catch(() => { });
      }
    } catch (cuErr) {
      /* ignore */
    }

    // Re-fetch updated row
    const updated = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(member_id).all();
    const updatedRow = updated.results[0];
    const order = buildOrderObject(member_id, updatedRow, totalsRes);

    // Fire mailer webhook for activation (non-blocking)
    try {
      if (env.MAILER_WEBHOOK && (updatedRow.email || member.email)) {
        const payload = {
          type: 'activation',
          email: updatedRow.email || member.email,
          member_id,
          activation_url: updatedRow.activation_url || (`https://kenfolios.com/community?activation=${encodeURIComponent(unique_token)}`),
          order_ref: updatedRow.ref_id || null,
          totals: totalsRes,
          timestamp: new Date().toISOString()
        };
        fireMailerWebhook(env, payload);
      }
    } catch (e) {
      console.error('mail webhook error (activation):', String(e));
    }

    return json({ ok: true, message: "Payment confirmed", member_id, order }, 200, origin);

  } catch (err) {
    console.error("Payment confirm error:", String(err));
    return json({ ok: false, message: "Payment confirmation failed", error: String(err) }, 500, origin);
  }
}

// ---------------- NEW: V2 handler: uses activation_* fields + signature check ----------------
async function handlePaymentConfirmV2(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request, env, origin);

  const member_id = Number(body.member_id || body.memberId);
  const razorpayPaymentId = body.razorpay_payment_id || body.razorpayPaymentId || null;
  const razorpayOrderId = body.razorpay_order_id || body.razorpayOrderId || null;
  const razorpaySignature = body.razorpay_signature || body.razorpaySignature || null;
  const coupon = body.coupon || body.coupon_code || body.couponCode || null;

  if (!member_id) return json({ ok: false, message: "member_id required" }, 400, origin);

  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(member_id).all();
    if (!lookup || !lookup.results || !lookup.results[0]) {
      return json({ ok: false, message: "Member not found" }, 404, origin);
    }

    const member = lookup.results[0];

    // Already paid? just return current order
    if (member.activation_fee_status === 'paid') {
      const orderAlready = buildOrderObject(member_id, member, null);
      return json({
        ok: true,
        message: "Already marked paid",
        reason: "already_paid",
        order: orderAlready
      }, 200, origin);
    }

    // Verify Razorpay signature if secret present
    if (!env.RAZORPAY_KEY_SECRET) {
      return json({ ok: false, message: "RAZORPAY_KEY_SECRET not configured" }, 500, origin);
    }

    const sigOk = await verifyRazorpaySignature(
      env.RAZORPAY_KEY_SECRET,
      razorpayOrderId,
      razorpayPaymentId,
      razorpaySignature
    );

    if (!sigOk) {
      try {
        await db.prepare(`
          UPDATE members
          SET
            activation_gateway_status = ?,
            activation_last_error = ?,
            activation_attempt_count = activation_attempt_count + 1
          WHERE id = ?;
        `).bind("failed", "invalid_signature", member_id).run();
      } catch (e) {
        console.error("Failed to record invalid_signature:", String(e));
      }
      return json({ ok: false, message: "Invalid payment signature" }, 400, origin);
    }

    // Totals (server-authoritative)
    const totalsRes = applyCouponAndTotals(
      BASE_PRODUCT.base_price,
      coupon || member.activation_coupon_code || null
    );
    if (totalsRes.error) {
      return json({ ok: false, message: totalsRes.error }, 400, origin);
    }

    const nowIso = new Date().toISOString();
    const nowSec = Math.floor(Date.now() / 1000);

    // Mark payment + gateway details using EXISTING columns only
    try {
      const updateSql = `
        UPDATE members
        SET
          activation_fee_status = 'paid',
          activation_fee_currency = COALESCE(activation_fee_currency, ?),
          activation_fee_amount = ?,
          activation_fee_discount_amount = ?,
          activation_fee_final_amount = ?,
          activation_coupon_code = COALESCE(activation_coupon_code, ?),
          activation_fee_paid_at = ?,
          activation_gateway_payment_id = COALESCE(activation_gateway_payment_id, ?),
          activation_gateway_order_id = COALESCE(activation_gateway_order_id, ?),
          activation_gateway_signature = COALESCE(activation_gateway_signature, ?),
          activation_gateway_status = 'captured',
          activation_captured_at = COALESCE(activation_captured_at, ?),
          activation_attempt_count = activation_attempt_count + 1
        WHERE id = ?;
      `;
      await db.prepare(updateSql).bind(
        BASE_PRODUCT.currency,
        totalsRes.total,
        totalsRes.discount,
        totalsRes.total,
        coupon || member.activation_coupon_code || null,
        nowIso,
        razorpayPaymentId || null,
        razorpayOrderId || null,
        razorpaySignature || null,
        nowSec,
        member_id
      ).run();
    } catch (upErr) {
      console.error("Payment confirm-v2 update failed:", String(upErr));
      return json({ ok: false, message: "Payment update failed", error: String(upErr) }, 500, origin);
    }

    // Generate unique_token + activation_url (same semantics as old handler, but query-param style)
    let unique_token = null;
    let activation_url = null;
    try {
      const after = await db.prepare("SELECT unique_token, activation_url, ref_id, email FROM members WHERE id = ? LIMIT 1")
        .bind(member_id).all();
      const existing = (after && after.results && after.results[0]) ? after.results[0] : null;
      unique_token = existing && existing.unique_token ? existing.unique_token : null;
      activation_url = existing && existing.activation_url ? existing.activation_url : null;

      if (!unique_token) {
        unique_token = generateUniqueToken(28);
        activation_url = `https://kenfolios.com/community?activation=${encodeURIComponent(unique_token)}`;
        await db.prepare(`
          UPDATE members
          SET unique_token = ?, activation_url = ?, activated_at = COALESCE(activated_at, ?)
          WHERE id = ?;
        `).bind(unique_token, activation_url, nowIso, member_id).run();
      } else if (!activation_url) {
        activation_url = `https://kenfolios.com/community?activation=${encodeURIComponent(unique_token)}`;
        await db.prepare(`
          UPDATE members
          SET activation_url = ?, activated_at = COALESCE(activated_at, ?)
          WHERE id = ?;
        `).bind(activation_url, nowIso, member_id).run();
      }
    } catch (tErr) {
      console.error("Failed to set unique_token/activation_url (v2):", String(tErr));
    }

    // Re-fetch updated row
    const updated = await db.prepare("SELECT * FROM members WHERE id = ? LIMIT 1")
      .bind(member_id).all();
    const updatedRow = (updated && updated.results && updated.results[0]) ? updated.results[0] : member;
    const order = buildOrderObject(member_id, updatedRow, totalsRes);

    // Fire mailer webhook for activation (same pattern as old handler)
    try {
      if (env.MAILER_WEBHOOK && (updatedRow.email || member.email)) {
        const payload = {
          type: 'activation',
          email: updatedRow.email || member.email,
          member_id,
          activation_url: updatedRow.activation_url || activation_url,
          order_ref: updatedRow.ref_id || null,
          totals: totalsRes,
          timestamp: new Date().toISOString()
        };
        fireMailerWebhook(env, payload);
      }
    } catch (e) {
      console.error('mail webhook error (activation-v2):', String(e));
    }

    return json({ ok: true, message: "Payment confirmed", member_id, order }, 200, origin);

  } catch (err) {
    console.error("Payment confirm-v2 error:", String(err));
    return json({ ok: false, message: "Payment confirmation failed", error: String(err) }, 500, origin);
  }
}

// ---------------- NEW handler: Fetch order by ref_id ----------------
async function handleFetchOrderByRef(request, env, origin) {
  const db = env.D1_WRITE_BINDING;
  const body = await parseJsonSafe(request);
  const ref_id = (body.ref_id || body.refId || '').toString().trim();
  if (!ref_id) {
    return json({ ok: false, message: "ref_id required" }, 400, origin);
  }
  try {
    const lookup = await db.prepare("SELECT * FROM members WHERE ref_id = ? LIMIT 1")
      .bind(ref_id).all();
    if (!lookup || !lookup.results || !lookup.results[0]) {
      console.warn('handleFetchOrderByRef: not found', ref_id);
      return json({ ok: false, message: "Order not found" }, 404, origin);
    }
    const member = lookup.results[0];
    const order = buildOrderObject(member.id, member, null);
    return json({ ok: true, order }, 200, origin);
  } catch (err) {
    console.error('handleFetchOrderByRef error:', String(err));
    return json({ ok: false, message: "Internal error" }, 500, origin);
  }
}

// -------------------------------------------------------------------
// ---------------- Order builder & helpers ----------------
function buildOrderObject(memberId, memberRow, totalsOverride) {
  const member = memberRow ? {
    id: memberRow.id,
    full_name: memberRow.full_name,
    email: memberRow.email,
    phone: memberRow.phone,
    city: memberRow.city,
    dob: memberRow.dob,
    gender: memberRow.gender,
    expectations: memberRow.expectations
  } : {};
  const order_ref = memberRow && memberRow.ref_id
    ? memberRow.ref_id
    : generateRefFromMember(memberId);
  const totals = totalsOverride
    ? totalsOverride
    : applyCouponAndTotals(
        BASE_PRODUCT.base_price,
        memberRow && memberRow.activation_coupon_code
          ? memberRow.activation_coupon_code
          : null
      );
  const status = (memberRow && memberRow.activation_fee_status === 'paid') ? 'paid' : 'pending';
  const editable = status !== 'paid';
  const available_coupons = Object.values(COUPONS).map(c => ({
    code: c.code,
    type: c.type,
    amount: c.amount || null,
    pct: c.pct || null,
    cap: c.cap || null,
    min: c.min || 0
  }));

  // Build order_created_at: prefer activation_created_at (UNIX secs), else created_at ISO, else now
  let order_created_at = null;
  if (memberRow && memberRow.activation_created_at) {
    try {
      const sec = Number(memberRow.activation_created_at);
      if (!isNaN(sec)) order_created_at = new Date(sec * 1000).toISOString();
    } catch (e) { /* ignore */ }
  }
  if (!order_created_at && memberRow && memberRow.created_at) {
    order_created_at = (new Date(memberRow.created_at)).toISOString();
  }
  if (!order_created_at) order_created_at = (new Date()).toISOString();

  // Ensure order_url uses query param style
  const order_url = memberRow && memberRow.order_url
    ? memberRow.order_url
    : `https://kenfolios.com/community?order=${encodeURIComponent(order_ref)}`;

  const activation_url = memberRow && memberRow.activation_url
    ? memberRow.activation_url
    : (memberRow && memberRow.unique_token
        ? `https://kenfolios.com/community?activation=${encodeURIComponent(memberRow.unique_token)}`
        : null);

  return {
    order_ref,
    order_created_at,
    order_url,
    activation_url,
    ref_id: order_ref,
    member: member,
    product: {
      name: BASE_PRODUCT.name,
      base_price: BASE_PRODUCT.base_price,
      currency: BASE_PRODUCT.currency
    },
    available_coupons,
    applied_coupon: totals.applied_coupon || null,
    totals: {
      subtotal: totals.subtotal,
      discount: totals.discount,
      taxable: totals.taxable,
      gst: totals.gst,
      total: totals.total
    },
    status,
    editable,
    company: buildCompanyBlock()
  };
}

async function readMemberCountOrFallback(db) {
  try {
    const metaRes = await db.prepare("SELECT value FROM meta WHERE key = 'member_count' LIMIT 1").all();
    if (metaRes && metaRes.results && metaRes.results[0] && metaRes.results[0].value != null) {
      return Number(metaRes.results[0].value) || 0;
    } else {
      const cntRes = await db.prepare("SELECT COUNT(*) AS cnt FROM members").all();
      if (cntRes && cntRes.results && cntRes.results[0] && cntRes.results[0].cnt != null) {
        return Number(cntRes.results[0].cnt) || 0;
      }
    }
  } catch (err) {
    console.error("count read failed:", String(err));
  }
  return null;
}
