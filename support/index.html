/**
 * =========================================================
 * KenFolios Support Intake Worker
 * =========================================================
 *
 * Worker name:
 *   kf-support-aegis-bold-star-4d27
 *
 * Public endpoint:
 *   POST /api/support
 *   POST /api/support/
 *
 * Purpose:
 *   - Accepts support requests from KenFolios users
 *   - Enforces mandatory Terms & Conditions acceptance
 *   - Prevents abuse via IP + email rate limiting
 *   - Generates a human-friendly, unguessable support ID
 *   - Persists request metadata safely in D1
 *
 * Key guarantees:
 *   - No submission without terms acceptance
 *   - Rate-limited (IP + email)
 *   - support_id is unique and sequentially suffixed (>=126)
 *   - Email sending is optional and non-blocking
 *
 * Database (D1) binding:
 *   SUPPORT_DB
 *
 * Tables used:
 *   - support_tickets
 *   - support_rate_limits
 *
 * Notes:
 *   - Attachments intentionally excluded (future R2 scope)
 *   - Email auto-enables when Brevo env vars are present
 * =========================================================
 */

const JSON_HEADERS = {
  "Content-Type": "application/json; charset=utf-8",
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type"
};

export default {
  async fetch(req, env) {
    const url = new URL(req.url);

    /* =====================================================
       STRICT ROUTE GUARD
    ===================================================== */
    if (url.pathname !== "/api/support" && url.pathname !== "/api/support/") {
      return new Response("Not found", { status: 404 });
    }

    /* Preflight */
    if (req.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: JSON_HEADERS });
    }

    if (req.method !== "POST") {
      return respond({ error: "Method not allowed" }, 405);
    }

    try {
      /* =====================================================
         REQUEST METADATA
      ===================================================== */
      const ip =
        req.headers.get("CF-Connecting-IP") ||
        req.headers.get("X-Forwarded-For") ||
        "unknown";

      const userAgent = req.headers.get("User-Agent") || "";

      /* =====================================================
         INPUT PARSING & VALIDATION
      ===================================================== */
      let body;
      try {
        body = await req.json();
      } catch {
        return respond({ error: "Invalid JSON body" }, 400);
      }

      const name = body.name?.trim();
      const email = body.email?.trim().toLowerCase();
      const phone = body.phone?.trim() || null;
      const category = body.category?.trim();
      const message = body.message?.trim();
      const termsAccepted = body.termsAccepted === true;

      if (!name || !email || !category || !message) {
        return respond({ error: "Missing required fields" }, 400);
      }

      if (!termsAccepted) {
        return respond({ error: "Terms must be accepted" }, 400);
      }

      /* =====================================================
         RATE LIMITING
         - IP:    10 requests/day
         - Email: 5 requests/day
      ===================================================== */
      await enforceRateLimit(env, ip, "ip", 10);
      await enforceRateLimit(env, email, "email", 5);

      /* =====================================================
         ID GENERATION
      ===================================================== */
      const ticketId = crypto.randomUUID(); // internal reference
      const supportId = await generateSupportId(env); // user-facing

      /* =====================================================
         DATABASE INSERT
      ===================================================== */
      await env.SUPPORT_DB.prepare(`
        INSERT INTO support_tickets
        (
          ticket_id,
          support_id,
          name,
          email,
          phone,
          category,
          message,
          terms_accepted,
          ip_address,
          user_agent
        )
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).bind(
        ticketId,
        supportId,
        name,
        email,
        phone,
        category,
        message,
        1,
        ip,
        userAgent
      ).run();

      /* =====================================================
         OPTIONAL EMAIL (NON-BLOCKING)
      ===================================================== */
      if (canSendEmail(env)) {
        sendSupportEmail(env, {
          toEmail: email,
          name,
          supportId
        }).catch(err => {
          console.warn("Support email failed:", err);
        });
      }

      /* =====================================================
         SUCCESS RESPONSE
      ===================================================== */
      return respond({
        success: true,
        support_id: supportId,
        message:
          "Your support request has been received. Our team will address your query very soon."
      });

    } catch (err) {
      console.error("kf-support-aegis error:", err);
      return respond({ error: "Internal server error" }, 500);
    }
  }
};

/* =========================================================
   RESPONSE HELPER
========================================================= */

function respond(data, status = 200) {
  return new Response(JSON.stringify(data), {
    status,
    headers: JSON_HEADERS
  });
}

/* =========================================================
   RATE LIMITING (D1-BASED)
========================================================= */

async function enforceRateLimit(env, identifier, type, maxPerDay) {
  const today = new Date().toISOString().slice(0, 10);

  const row = await env.SUPPORT_DB.prepare(`
    SELECT id, count
    FROM support_rate_limits
    WHERE identifier = ? AND type = ? AND last_seen = ?
  `).bind(identifier, type, today).first();

  if (!row) {
    await env.SUPPORT_DB.prepare(`
      INSERT INTO support_rate_limits (identifier, type, count, last_seen)
      VALUES (?, ?, 1, ?)
    `).bind(identifier, type, today).run();
    return;
  }

  if (row.count >= maxPerDay) {
    throw new Error("Rate limit exceeded");
  }

  await env.SUPPORT_DB.prepare(`
    UPDATE support_rate_limits
    SET count = count + 1
    WHERE id = ?
  `).bind(row.id).run();
}

/* =========================================================
   SUPPORT ID GENERATOR
   Format: RANDOM(9) + SEQUENTIAL NUMBER (>=126)
========================================================= */

async function generateSupportId(env) {
  const row = await env.SUPPORT_DB.prepare(`
    SELECT support_id
    FROM support_tickets
    WHERE support_id IS NOT NULL
    ORDER BY id DESC
    LIMIT 1
  `).first();

  let next = 126;
  if (row?.support_id) {
    const m = row.support_id.match(/(\d+)$/);
    if (m) next = parseInt(m[1], 10) + 1;
  }

  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  const randomPart = () =>
    Array.from({ length: 9 }, () =>
      chars[Math.floor(Math.random() * chars.length)]
    ).join("");

  for (let i = 0; i < 3; i++) {
    const candidate = `${randomPart()}${next}`;
    const exists = await env.SUPPORT_DB
      .prepare(`SELECT 1 FROM support_tickets WHERE support_id = ?`)
      .bind(candidate)
      .first();
    if (!exists) return candidate;
  }

  throw new Error("support_id generation failed");
}

/* =========================================================
   EMAIL (BREVO) — OPTIONAL
========================================================= */

function canSendEmail(env) {
  return (
    env.BREVO_API_KEY &&
    env.BREVO_SENDER_EMAIL &&
    env.BREVO_SENDER_NAME
  );
}

async function sendSupportEmail(env, { toEmail, name, supportId }) {
  const payload = {
    sender: {
      email: env.BREVO_SENDER_EMAIL,
      name: env.BREVO_SENDER_NAME
    },
    to: [{ email: toEmail, name }],
    subject: `Support request received — ${supportId}`,
    htmlContent: `
      <div style="font-family:system-ui,-apple-system,Segoe UI,Roboto">
        <p>Hi ${escapeHtml(name)},</p>
        <p>Your support request has been received.</p>
        <p><strong>Support ID:</strong><br/>
        <code style="font-size:15px">${supportId}</code></p>
        <p>Our team will address your query very soon.</p>
        <p style="color:#64748b;font-size:13px">
          — KenFolios Support Team
        </p>
      </div>
    `
  };

  await fetch("https://api.brevo.com/v3/smtp/email", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "api-key": env.BREVO_API_KEY
    },
    body: JSON.stringify(payload)
  });
}

function escapeHtml(str) {
  return str.replace(/[&<>"']/g, c =>
    ({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[c])
  );
}
